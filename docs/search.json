[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso ROC: Análisis de datos de eBird utilizando R",
    "section": "",
    "text": "Introducción\nEsta página contiene el material utilizado durante el Curso Roc: Análisis de datos de eBird utilizando R.\nEl curso consta de 4 módulos:\n1. Introducción al entorno R en el contexto de eBird\n2. Buenas prácticas para el uso de datos de eBird: introduction to the eBird Basic Dataset (EBD), challenges associated with using eBird data for analysis, and best practices for preparing eBird data for modeling.\n3. Modelamiento de distribución y abundancia relativa: tasas de encuentro, abundancia relativa y ejemplos y aplicaciones prácticas usando distribución y abundancia.\n4. Usos y aplicaciones de productos Estados y Tendencias: descarga de productos de Estados y Tendencias, carga de datos en R y su uso para una variedad de aplicaciones.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#sec-intro-setup",
    "href": "index.html#sec-intro-setup",
    "title": "Curso ROC: Análisis de datos de eBird en R",
    "section": "Setup",
    "text": "Setup\nThis workshop is intended to be interactive. All examples are written in the R programming language, and the instructor will work through the examples in real time, while the attendees are encouraged following along by writing the same code. To ensure we can avoid any unnecessary delays, please follow these setup instructions prior to the workshop:\n\nCreate an eBird account if you don’t already have one and request access to the raw eBird data and/or the eBird Status data products depending on which workshops you’re attending:\n\nBest Practices for Using eBird Data: request access to the eBird Basic Dataset.\neBird Status and Trends: request access to the eBird Status data products\n\nDownload and install the latest version of R. You must have R version 4.0.0 or newer to follow along with this workshop\nDownload and install the latest version of RStudio. RStudio is not required for this workshop; however, the instructors will be using it and you may find it easier to following along if you’re working in the same environment.\nThe lessons in this workshop use a variety of R packages. To install all the necessary packages, run the following code\n\n\nif (!requireNamespace(\"remotes\", quietly = TRUE)) {\n  install.packages(\"remotes\")\n}\nremotes::install_github(\"ebird/ebird-best-practices\")\n\n\nEnsure all packages are updated to their most recent versions by clicking on the Update button on the Packages tab in RStudio.\nDownload the data package for the workshop you are attending:\n\nBest Practices for Using eBird Data\neBird Status and Trends",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#sec-intro-tidyverse",
    "href": "index.html#sec-intro-tidyverse",
    "title": "Curso ROC: Análisis de datos de eBird en R",
    "section": "Tidyverse",
    "text": "Tidyverse\nThroughout this workshop, we use packages from the Tidyverse, an opinionated collection of R packages designed for data science. Packages such as ggplot2, for data visualization, and dplyr, for data manipulation, are two of the most well known Tidyverse packages; however, there are many more. We’ll try to explain any functions as they come up; however, for a good general resource on working with data in R using the Tidyverse see the free online book R for Data Science by Hadley Wickham.\nThe one piece of the Tidyverse that we will cover up front is the pipe operator %&gt;%. The pipe takes the expression to the left of it and “pipes” it into the first argument of the expression on the right.\n\nlibrary(dplyr)\n\n# without pipe\nmean(1:10)\n#&gt; [1] 5.5\n\n# with pipe\n1:10 %&gt;% mean()\n#&gt; [1] 5.5\n\nThe pipe can code significantly more readable by avoiding nested function calls, reducing the need for intermediate variables, and making sequential operations read left-to-right. For example, to add a new variable to a data frame, then summarize using a grouping variable, the following are equivalent:\n\n# intermediate variables\nmtcars_kg &lt;- mutate(mtcars, wt_kg = 454 * wt)\nmtcars_grouped &lt;- group_by(mtcars_kg, cyl)\nsummarize(mtcars_grouped, wt_kg = mean(wt_kg))\n#&gt; # A tibble: 3 × 2\n#&gt;     cyl wt_kg\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4 1038.\n#&gt; 2     6 1415.\n#&gt; 3     8 1816.\n\n# nested function calls\nsummarize(\n  group_by(\n    mutate(mtcars, wt_kg = 454 * wt),\n    cyl\n  ),\n  wt_kg = mean(wt_kg)\n)\n#&gt; # A tibble: 3 × 2\n#&gt;     cyl wt_kg\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4 1038.\n#&gt; 2     6 1415.\n#&gt; 3     8 1816.\n\n# pipes\nmtcars %&gt;% \n  mutate(wt_kg = 454 * wt) %&gt;% \n  group_by(cyl) %&gt;% \n  summarize(wt_kg = mean(wt_kg))\n#&gt; # A tibble: 3 × 2\n#&gt;     cyl wt_kg\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4 1038.\n#&gt; 2     6 1415.\n#&gt; 3     8 1816.\n\n\n\n\n\n\n\nExercise\n\n\n\nRewrite the following code using pipes:\n\nset.seed(1)\nround(log(runif(10, min = 0.5)), 1)\n#&gt;  [1] -0.5 -0.4 -0.2  0.0 -0.5 -0.1  0.0 -0.2 -0.2 -0.6\n\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nset.seed(1)\nrunif(10, min = 0.5) %&gt;% \n  log() %&gt;% \n  round(digits = 1)\n#&gt;  [1] -0.5 -0.4 -0.2  0.0 -0.5 -0.1  0.0 -0.2 -0.2 -0.6",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "ebird.html#sec-ebird-intro",
    "href": "ebird.html#sec-ebird-intro",
    "title": "1  Best Practices for using eBird Data",
    "section": "1.1 Introduction",
    "text": "1.1 Introduction\neBird data are collected and organized around the concept of a checklist, representing observations from a single birding event, such as a 1 km walk through a park or 15 minutes observing bird feeders in your backyard. All eBird checklists contains a list of species observed and the location and time of the observations. For a subset of checklists, the observer will also provide counts of the number of individuals seen of each species, specify the amount of effort expended while collecting these data, and confirm that they are submitting a complete checklist of all the birds they were able to identify. The data provided by the checklists such as these are often referred to as semi-structured citizen science data. Importantly, complete checklists enable data users to infer counts of zero individuals for the species that were not reported. If checklists are not complete, it’s not possible to ascertain whether the absence of a species on a list was a non-detection or the result of a participant not recording the species.\nLet’s compare two eBird checklists: an incidental observation with missing counts and a complete traveling count. Both checklists can be useful, but only the second checklist provides the type of semi-structured data required for more rigorous applications."
  },
  {
    "objectID": "ebird.html#sec-ebird-download",
    "href": "ebird.html#sec-ebird-download",
    "title": "1  Best Practices for using eBird Data",
    "section": "1.2 Downloading data",
    "text": "1.2 Downloading data\neBird data are released as two tab-separated text files: the eBird Basic Dataset (EBD) containing observation data and the Sampling Event Data (SED) containing checklist data. These files are released monthly and contain all validated bird sightings in the eBird database at the time of release. In the EBD, each row corresponds to the sighting of a single species on a checklist, including the count and any other species-level information (e.g. age, sex, species comments, etc.). In the SED, each row corresponds to a checklist, including the date, time, location, effort (e.g. distance traveled, time spent, etc.), and any additional checklist-level information (e.g. whether this is a complete checklist or not).\nIn this workshop, we’ll use Fork-tailed Flycatcher observations from Rio Grande do Sul, Brazil as an example. We’ll start by downloading the corresponding eBird observation (EBD) and checklist (SED) data by visiting the eBird Basic Dataset download page and filling out the Custom Download form to request Fork-tailed Flycatcher observations from Rio Grande do Sul. Make sure you check the box “Include sampling event data”, which will include the SED in the data download in addition to the EBD.\n\n\n\n\n\n\n\nTip\n\n\n\nThe eBird database contains a massive amount of data! When requesting eBird data to download it’s important to narrow the request to as small a subset of the data as possible. For example, if we request all Fork-tailed Flycatcher observations globally, the dataset may be too large to work with in R. Instead, we’ve only requested data for a single state in Brazil.\n\n\nOnce the data are ready, you will receive an email with a download link. The downloaded data will be in a compressed .zip format, and should be unarchived. The resulting directory will contain a two text files: one for the EBD (e.g. ebd_BR-RS_fotfly_smp_relJun-2023.txt) containing all the Fork-tailed flycatcher observations from Rio Grande do Sul, and one for the SED (e.g. ebd_BR-RS_fotfly_smp_relJun-2023_sampling.txt) containing all checklists from Rio Grande do Sul, The relJune-2023 component of the file name describes which version of the EBD this dataset came from; in this case it’s the June 2023 release.\nIf you would prefer to directly download the exact dataset used in this workshop, download the data package for this workshop."
  },
  {
    "objectID": "ebird.html#sec-ebird-import",
    "href": "ebird.html#sec-ebird-import",
    "title": "1  Best Practices for using eBird Data",
    "section": "1.3 Importing eBird data into R",
    "text": "1.3 Importing eBird data into R\nThe previous step left us with two tab separated text files, one for the EBD (i.e. observation data) and one for the SED (i.e. checklist data). Start a new RStudio project and put the downloaded text files in the data/ sub-directory of the project directory.\nThe auk R package is specifically designed for working with eBird data. It includes the functions read_ebd() and read_sampling() for importing the EBD and SED, respectively, into R. First let’s import the checklist data (SED).\n\nlibrary(auk)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(lubridate)\nlibrary(sf)\n\nf_sed &lt;- \"data/ebd_BR-RS_fotfly_smp_relJun-2023_sampling.txt\"\nchecklists &lt;- read_sampling(f_sed, unique = FALSE)\nglimpse(checklists)\n#&gt; Rows: 34,005\n#&gt; Columns: 30\n#&gt; $ last_edited_date          &lt;chr&gt; \"2021-02-15 15:28:32.796728\", \"2021-12-12 14…\n#&gt; $ country                   &lt;chr&gt; \"Brazil\", \"Brazil\", \"Brazil\", \"Brazil\", \"Bra…\n#&gt; $ country_code              &lt;chr&gt; \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"B…\n#&gt; $ state                     &lt;chr&gt; \"Rio Grande do Sul\", \"Rio Grande do Sul\", \"R…\n#&gt; $ state_code                &lt;chr&gt; \"BR-RS\", \"BR-RS\", \"BR-RS\", \"BR-RS\", \"BR-RS\",…\n#&gt; $ county                    &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ county_code               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ iba_code                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ bcr_code                  &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ usfws_code                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ atlas_block               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ locality                  &lt;chr&gt; \"UFRGS--Estação Experimental Agronômica\", \"C…\n#&gt; $ locality_id               &lt;chr&gt; \"L10057337\", \"L10637103\", \"L10637103\", \"L108…\n#&gt; $ locality_type             &lt;chr&gt; \"H\", \"P\", \"P\", \"P\", \"H\", \"H\", \"H\", \"P\", \"P\",…\n#&gt; $ latitude                  &lt;dbl&gt; -30.1, -28.2, -28.2, -30.4, -32.6, -31.2, -3…\n#&gt; $ longitude                 &lt;dbl&gt; -51.7, -51.7, -51.7, -51.5, -52.8, -50.8, -5…\n#&gt; $ observation_date          &lt;date&gt; 1993-03-22, 1998-12-11, 1999-12-27, 1990-01…\n#&gt; $ time_observations_started &lt;chr&gt; \"08:00:00\", \"09:00:00\", \"09:00:00\", NA, NA, …\n#&gt; $ observer_id               &lt;chr&gt; \"obs203567\", \"obs1166183\", \"obs1166183\", \"ob…\n#&gt; $ sampling_event_identifier &lt;chr&gt; \"S81646316\", \"S98801647\", \"S98802795\", \"S758…\n#&gt; $ protocol_type             &lt;chr&gt; \"Traveling\", \"Traveling\", \"Traveling\", \"Inci…\n#&gt; $ protocol_code             &lt;chr&gt; \"P22\", \"P22\", \"P22\", \"P20\", \"P20\", \"P62\", \"P…\n#&gt; $ project_code              &lt;chr&gt; \"EBIRD\", \"EBIRD\", \"EBIRD\", \"EBIRD\", \"EBIRD\",…\n#&gt; $ duration_minutes          &lt;int&gt; 195, 120, 120, NA, NA, 90, NA, 80, NA, NA, N…\n#&gt; $ effort_distance_km        &lt;dbl&gt; 3.22, 2.00, 2.00, NA, NA, NA, NA, 4.00, NA, …\n#&gt; $ effort_area_ha            &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ number_observers          &lt;int&gt; 2, 1, 1, NA, NA, 2, NA, 1, 1, 2, 1, 1, 1, 2,…\n#&gt; $ all_species_reported      &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE, FALSE, FALSE, FALS…\n#&gt; $ group_identifier          &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ trip_comments             &lt;chr&gt; NA, \"lista feita por LB.\", \"lista feita por …\n\n\n\n\n\n\n\nCheckpoint\n\n\n\nTake some time to explore the variables in the checklist dataset. If you’re unsure about any of the variables, consult the metadata document that came with the data download (eBird_Basic_Dataset_Metadata_v1.14.pdf).\n\n\nFor some applications, only the checklist data are required. For example, the checklist data can be used to investigate the spatial and temporal distribution of eBird data within a region. This dataset can also be used to explore how much variation there is in the observation effort variables and identify checklists that have low spatial or temporal precision.\n\n\n\n\n\n\nExercise\n\n\n\nMake a histogram of the distribution of distance traveling for traveling protocol checklists.\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNearly 90% of checklists are less than 10km in length; however, some checklists are as long as 80km in length. Long traveling checklists have lower spatial precision so they should generally be removed prior to analysis.\n\nchecklists_traveling &lt;- filter(checklists, protocol_type == \"Traveling\")\nggplot(checklists_traveling) +\n  aes(x = effort_distance_km) +\n  geom_histogram(binwidth = 5) +\n  scale_y_continuous(limits = c(0, NA), labels = scales::comma) +\n  labs(x = \"Distance traveled [km]\",\n       y = \"# of eBird checklists\",\n       title = \"Distribution of distance traveled on eBird checklists\")\n\n\n\n\n\n\n\n\n\n\n\nNext, let’s import the observation data.\n\nf_ebd &lt;- \"data/ebd_BR-RS_fotfly_smp_relJun-2023.txt\"\nobservations &lt;- read_ebd(f_ebd, unique = FALSE, rollup = FALSE)\nglimpse(observations)\n#&gt; Rows: 4,810\n#&gt; Columns: 49\n#&gt; $ global_unique_identifier   &lt;chr&gt; \"URN:CornellLabOfOrnithology:EBIRD:OBS10006…\n#&gt; $ last_edited_date           &lt;chr&gt; \"2023-05-11 20:08:09.920625\", \"2022-08-04 0…\n#&gt; $ taxonomic_order            &lt;dbl&gt; 17062, 17062, 17062, 17062, 17062, 17062, 1…\n#&gt; $ category                   &lt;chr&gt; \"species\", \"species\", \"species\", \"species\",…\n#&gt; $ taxon_concept_id           &lt;chr&gt; \"avibase-A2510EF4\", \"avibase-A2510EF4\", \"av…\n#&gt; $ common_name                &lt;chr&gt; \"Fork-tailed Flycatcher\", \"Fork-tailed Flyc…\n#&gt; $ scientific_name            &lt;chr&gt; \"Tyrannus savana\", \"Tyrannus savana\", \"Tyra…\n#&gt; $ subspecies_common_name     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ subspecies_scientific_name &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ exotic_code                &lt;lgl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ observation_count          &lt;chr&gt; \"X\", \"1\", \"4\", \"1\", \"X\", \"X\", \"X\", \"X\", \"X\"…\n#&gt; $ breeding_code              &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ breeding_category          &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ behavior_code              &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ age_sex                    &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ country                    &lt;chr&gt; \"Brazil\", \"Brazil\", \"Brazil\", \"Brazil\", \"Br…\n#&gt; $ country_code               &lt;chr&gt; \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"…\n#&gt; $ state                      &lt;chr&gt; \"Rio Grande do Sul\", \"Rio Grande do Sul\", \"…\n#&gt; $ state_code                 &lt;chr&gt; \"BR-RS\", \"BR-RS\", \"BR-RS\", \"BR-RS\", \"BR-RS\"…\n#&gt; $ county                     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ county_code                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ iba_code                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ bcr_code                   &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ usfws_code                 &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ atlas_block                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ locality                   &lt;chr&gt; \"São Francisco de Paula--listas históricas …\n#&gt; $ locality_id                &lt;chr&gt; \"L2862103\", \"L2453957\", \"L2312691\", \"L23126…\n#&gt; $ locality_type              &lt;chr&gt; \"H\", \"H\", \"P\", \"P\", \"P\", \"P\", \"P\", \"H\", \"H\"…\n#&gt; $ latitude                   &lt;dbl&gt; -29.4, -31.3, -29.4, -29.4, -29.7, -28.2, -…\n#&gt; $ longitude                  &lt;dbl&gt; -50.6, -51.0, -50.6, -50.6, -50.0, -51.7, -…\n#&gt; $ observation_date           &lt;date&gt; 1993-11-06, 1996-09-28, 1996-10-17, 1996-1…\n#&gt; $ time_observations_started  &lt;chr&gt; NA, \"07:00:00\", \"15:00:00\", \"06:00:00\", NA,…\n#&gt; $ observer_id                &lt;chr&gt; \"obsr477997\", \"obsr556494\", \"obsr293781\", \"…\n#&gt; $ sampling_event_identifier  &lt;chr&gt; \"S75217442\", \"S28837996\", \"S14886987\", \"S14…\n#&gt; $ protocol_type              &lt;chr&gt; \"Historical\", \"Historical\", \"Traveling\", \"T…\n#&gt; $ protocol_code              &lt;chr&gt; \"P62\", \"P62\", \"P22\", \"P22\", \"P20\", \"P22\", \"…\n#&gt; $ project_code               &lt;chr&gt; \"EBIRD\", \"EBIRD\", \"EBIRD\", \"EBIRD\", \"EBIRD\"…\n#&gt; $ duration_minutes           &lt;int&gt; NA, 720, 120, 480, NA, 120, NA, NA, NA, 120…\n#&gt; $ effort_distance_km         &lt;dbl&gt; NA, NA, 1.61, 6.44, NA, 2.00, NA, NA, NA, 2…\n#&gt; $ effort_area_ha             &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ number_observers           &lt;int&gt; NA, 2, 12, 12, 1, 1, 1, 2, 1, 1, 8, 8, 2, 2…\n#&gt; $ all_species_reported       &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, …\n#&gt; $ group_identifier           &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ has_media                  &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F…\n#&gt; $ approved                   &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, T…\n#&gt; $ reviewed                   &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F…\n#&gt; $ reason                     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n#&gt; $ trip_comments              &lt;chr&gt; NA, NA, \"Victor Emanuel Nature Tours birdin…\n#&gt; $ species_comments           &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\n\n\n\n\n\n\nCheckpoint\n\n\n\nTake some time to explore the variables in the observation dataset. Notice that the EBD duplicates many of the checklist-level variables from the SED.\n\n\nWhen we read the data into R, we used unique = FALSE and rollup = FALSE. By default the read functions in auk perform two important pre-processing steps: combining duplicate shared checklists and taxonomic rollup. We intentionally turned off this functionality for the purposes of demonstration.\n\n1.3.1 Shared checklists\neBird allows users to share checklists with other eBirders in their group, for example this checklist is shared by 10 observers. These checklists can be identified by looking at the group_identifier variable, which assigns an ID connecting all checklists in the group.\n\nchecklists %&gt;% \n  filter(!is.na(group_identifier)) %&gt;% \n  arrange(group_identifier) %&gt;% \n  select(sampling_event_identifier, group_identifier)\n#&gt; # A tibble: 8,632 × 2\n#&gt;   sampling_event_identifier group_identifier\n#&gt;   &lt;chr&gt;                     &lt;chr&gt;           \n#&gt; 1 S133745869                G10019405       \n#&gt; 2 S134107963                G10019405       \n#&gt; 3 S134468930                G10040061       \n#&gt; 4 S134466265                G10040061       \n#&gt; 5 S134466330                G10040062       \n#&gt; 6 S134468944                G10040062       \n#&gt; # ℹ 8,626 more rows\n\nChecklists with the same group_identifier provide duplicate information on the same birding event in the eBird database. For most analyses, it’s important to collapse these shared checklists down into a single checklist. This can be accomplished with the function auk_unique(), which retains only one independent copy of each checklist.\n\nchecklists_unique &lt;- auk_unique(checklists, checklists_only = TRUE)\nnrow(checklists)\n#&gt; [1] 34005\nnrow(checklists_unique)\n#&gt; [1] 28930\n\nNotice that a new variable, checklist_id, was created that is set to group_identifier for shared checklists and sampling_event_identifier for non-shared checklists.\n\nhead(checklists_unique$checklist_id)\n#&gt; [1] \"S81646316\" \"S98801647\" \"S98802795\" \"S7580857\"  \"S7581039\"  \"S28832587\"\ntail(checklists_unique$checklist_id)\n#&gt; [1] \"G7592371\" \"G7592372\" \"G7573316\" \"G7594361\" \"G7633009\" \"G7603956\"\n\n\n\n\n\n\n\nTip\n\n\n\nCurious what checklists and observers contributed to a shared checklist after it has been collapsed? The sampling_event_identifier and observer_id contain comma-separated lists of all checklists and observers that went into the shared checklists.\n\nchecklists_unique %&gt;% \n  filter(checklist_id == \"G10019405\") %&gt;% \n  select(checklist_id, group_identifier, sampling_event_identifier, observer_id)\n#&gt; # A tibble: 1 × 4\n#&gt;   checklist_id group_identifier sampling_event_identifier observer_id         \n#&gt;   &lt;chr&gt;        &lt;chr&gt;            &lt;chr&gt;                     &lt;chr&gt;               \n#&gt; 1 G10019405    G10019405        S133745869,S134107963     obs1481597,obs567598\n\n\n\n\n\n1.3.2 Taxonomic rollup\neBird observations can be made at levels below species (e.g. subspecies) or above species (e.g. a bird that was identified as a duck, but the species could not be determined); however, for most uses we’ll want observations at the species level. This is especially true if we want to produce detection/non-detection data from complete checklists because “complete” only applies at the species level.\n\n\n\n\n\n\nTip\n\n\n\nIn the example dataset used for this workshop, these taxonomic issues don’t apply. We have requested Fork-tailed Flycatcher observations, so we haven’t received any observations for taxa above species, and Fork-tailed Flycatcher only has a single subspecies within Rio Grande do Sul. However, in many other situations, these taxonomic issues can be important. For example, this checklist has 10 Yellow-rumped Warblers, 5 each of two Yellow-rumped Warbler subspecies, and one hybrid between the two subspecies. auk_rollup() will combine all four of these observations into a single Yellow-rumped Warbler observation.\n\n\nThe function auk_rollup() drops all observations not identifiable to a species and rolls up all observations reported below species to the species level.\n\nobservations_rollup &lt;- auk_rollup(observations)\n# only one checklist is affected by this\nobservations %&gt;% \n  filter(sampling_event_identifier == \"S99335111\") %&gt;% \n  select(sampling_event_identifier, common_name, subspecies_common_name, \n         observation_count)\n#&gt; # A tibble: 2 × 4\n#&gt;   sampling_event_identifier common_name subspecies_common_name observation_count\n#&gt;   &lt;chr&gt;                     &lt;chr&gt;       &lt;chr&gt;                  &lt;chr&gt;            \n#&gt; 1 S99335111                 Fork-taile… &lt;NA&gt;                   X                \n#&gt; 2 S99335111                 Fork-taile… Fork-tailed Flycatche… 1\nobservations_rollup %&gt;% \n  filter(sampling_event_identifier == \"S99335111\") %&gt;% \n  select(sampling_event_identifier, common_name,\n         observation_count)\n#&gt; # A tibble: 1 × 3\n#&gt;   sampling_event_identifier common_name            observation_count\n#&gt;   &lt;chr&gt;                     &lt;chr&gt;                  &lt;chr&gt;            \n#&gt; 1 S99335111                 Fork-tailed Flycatcher X\n\n\n\n\n\n\n\nTip\n\n\n\nIf multiple taxa on a single checklist roll up to the same species, auk_rollup() attempts to combine them intelligently. If each observation has a count, those counts are added together, but if any of the observations is missing a count (i.e. the count is “X”) the combined observation is also assigned an “X”. In the example checklist from the previous tip, with four taxa all rolling up to Yellow-rumped Warbler, auk_rollup() will add the four counts together to get 21 Yellow-rumped Warblers (10 + 5 + 5 + 1)."
  },
  {
    "objectID": "ebird.html#sec-ebird-zf",
    "href": "ebird.html#sec-ebird-zf",
    "title": "1  Best Practices for using eBird Data",
    "section": "1.4 Generating detection/non-detection data",
    "text": "1.4 Generating detection/non-detection data\nComplete eBird checklists are extremely valuable because, for all species that weren’t reported, we can infer counts of 0. This allows us to convert eBird from presence only data to detection/non-detection data, which allows for much more robust analyses. Note that we don’t use the term presence/absence data here because a non-detection doesn’t necessarily imply the species was absent, only that the observer didn’t detect and identify it.\nWe refer to the process of producing detection/non-detection data as “zero-filling” the eBird data because we’re filling in the missing zeros. We’ll read the eBird data into R again, filter to only complete checklists, then use the function auk_zerofill() to generate detection/non-detection data. Note that shared checklists are combined and taxonomic rollup is performed by default when using the read_*() functions from auk.\n\n# import checklist data\nchecklists &lt;- read_sampling(f_sed) %&gt;% \n  # subset to complete checklists\n  filter(all_species_reported)\n# import observation data\nobservations &lt;- read_ebd(f_ebd) %&gt;% \n  # subset to complete checklists\n  filter(all_species_reported)\n# zero-fill to produce detection/non-detection data\nzf &lt;- auk_zerofill(observations, checklists, collapse = TRUE)\nglimpse(zf)\n#&gt; Rows: 22,838\n#&gt; Columns: 38\n#&gt; $ checklist_id              &lt;chr&gt; \"S98801647\", \"S98802795\", \"S91164181\", \"S114…\n#&gt; $ last_edited_date          &lt;chr&gt; \"2021-12-12 14:52:43.115062\", \"2022-10-25 03…\n#&gt; $ country                   &lt;chr&gt; \"Brazil\", \"Brazil\", \"Brazil\", \"Brazil\", \"Bra…\n#&gt; $ country_code              &lt;chr&gt; \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"BR\", \"B…\n#&gt; $ state                     &lt;chr&gt; \"Rio Grande do Sul\", \"Rio Grande do Sul\", \"R…\n#&gt; $ state_code                &lt;chr&gt; \"BR-RS\", \"BR-RS\", \"BR-RS\", \"BR-RS\", \"BR-RS\",…\n#&gt; $ county                    &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ county_code               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ iba_code                  &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ bcr_code                  &lt;int&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ usfws_code                &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ atlas_block               &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ locality                  &lt;chr&gt; \"Capela Sagrado Coração de Jesus,RS,BR\", \"Ca…\n#&gt; $ locality_id               &lt;chr&gt; \"L10637103\", \"L10637103\", \"L15616802\", \"L165…\n#&gt; $ locality_type             &lt;chr&gt; \"P\", \"P\", \"P\", \"P\", \"H\", \"P\", \"P\", \"P\", \"P\",…\n#&gt; $ latitude                  &lt;dbl&gt; -28.2, -28.2, -29.3, -29.3, -29.5, -29.3, -3…\n#&gt; $ longitude                 &lt;dbl&gt; -51.7, -51.7, -49.7, -49.7, -50.6, -50.3, -5…\n#&gt; $ observation_date          &lt;date&gt; 1998-12-11, 1999-12-27, 1989-12-27, 1992-04…\n#&gt; $ time_observations_started &lt;chr&gt; \"09:00:00\", \"09:00:00\", \"07:30:00\", NA, NA, …\n#&gt; $ observer_id               &lt;chr&gt; \"obs1166183\", \"obs1166183\", \"obs501289\", \"ob…\n#&gt; $ sampling_event_identifier &lt;chr&gt; \"S98801647\", \"S98802795\", \"S91164181\", \"S114…\n#&gt; $ protocol_type             &lt;chr&gt; \"Traveling\", \"Traveling\", \"Traveling\", \"Hist…\n#&gt; $ protocol_code             &lt;chr&gt; \"P22\", \"P22\", \"P22\", \"P62\", \"P62\", \"P22\", \"P…\n#&gt; $ project_code              &lt;chr&gt; \"EBIRD\", \"EBIRD\", \"EBIRD\", \"EBIRD\", \"EBIRD\",…\n#&gt; $ duration_minutes          &lt;int&gt; 120, 120, 80, NA, NA, 180, NA, NA, 120, 480,…\n#&gt; $ effort_distance_km        &lt;dbl&gt; 2.000, 2.000, 4.000, NA, NA, 5.000, NA, NA, …\n#&gt; $ effort_area_ha            &lt;dbl&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ number_observers          &lt;int&gt; 1, 1, 1, 1, 2, 1, 3, 3, 12, 12, 12, 2, 1, NA…\n#&gt; $ all_species_reported      &lt;lgl&gt; TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TR…\n#&gt; $ group_identifier          &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ trip_comments             &lt;chr&gt; \"lista feita por LB.\", \"lista feita por LB.\"…\n#&gt; $ scientific_name           &lt;chr&gt; \"Tyrannus savana\", \"Tyrannus savana\", \"Tyran…\n#&gt; $ breeding_code             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ breeding_category         &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ behavior_code             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ age_sex                   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, …\n#&gt; $ observation_count         &lt;chr&gt; \"X\", \"X\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"4\",…\n#&gt; $ species_observed          &lt;lgl&gt; TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALS…\n\nThe observation_count variable has true counts as well as “X”s, which indicate that the species was detected but the number of individuals was not counted. auk_zerofill() adds a new binary column, species_observed, indicating whether or not the species was detected.\n\nselect(zf, observation_count, species_observed) %&gt;% \n  head(10)\n#&gt; # A tibble: 10 × 2\n#&gt;   observation_count species_observed\n#&gt;   &lt;chr&gt;             &lt;lgl&gt;           \n#&gt; 1 X                 TRUE            \n#&gt; 2 X                 TRUE            \n#&gt; 3 0                 FALSE           \n#&gt; 4 0                 FALSE           \n#&gt; 5 0                 FALSE           \n#&gt; 6 0                 FALSE           \n#&gt; # ℹ 4 more rows\n\nLet’s convert the “X”s to NAs and transform observation_count to an integer variable.\n\nzf$observation_count &lt;- if_else(zf$observation_count == \"X\", \n                                NA_character_, zf$observation_count) %&gt;% \n  as.integer()\nselect(zf, observation_count, species_observed) %&gt;% \n  head(10)\n#&gt; # A tibble: 10 × 2\n#&gt;   observation_count species_observed\n#&gt;               &lt;int&gt; &lt;lgl&gt;           \n#&gt; 1                NA TRUE            \n#&gt; 2                NA TRUE            \n#&gt; 3                 0 FALSE           \n#&gt; 4                 0 FALSE           \n#&gt; 5                 0 FALSE           \n#&gt; 6                 0 FALSE           \n#&gt; # ℹ 4 more rows"
  },
  {
    "objectID": "ebird.html#sec-ebird-filtering",
    "href": "ebird.html#sec-ebird-filtering",
    "title": "1  Best Practices for using eBird Data",
    "section": "1.5 Filtering data",
    "text": "1.5 Filtering data\nNow that you have a detection/non-detection dataset, it’s likely that you want to do something with it. For example, you may want to make a map, identify priority areas for a species, or train a species distribution model. Regardless of the specific application, it’s likely that some amount of filtering of the data is required first. Some of the ways you may want to filter eBird data include:\n\nTemporal filtering: filter the data to a specific range of years or to a specific time of year.\nSpatial filtering: filter the data to focus on a specific region, e.g. a protected area.\nIncreasing precision: some eBird checklists are quite long in distance or duration leading to spatial or temporal imprecision. By removing longer checklists we can increase the spatial precision of the dataset.\nReducing variation in effort: unlike structured scientific surveys, data can be submitted to eBird using a variety of protocols and there is significant variation in effort between checklists in the eBird dataset. Variation in protocol and effort leads to variation in detectability (more effort generally leads to higher detectability). We can choose to impose more structure on the eBird dataset by filtering to reduce variation in protocol and effort.\n\nThe specific filtering you apply will depend on how you intend to use the eBird data. However, for the sake of this example, let’s filter the eBird data to only traveling and stationary checklists from 2013-2022 that are less than 6 hours in duration and 10 km in length.\n\nzf_filtered &lt;- zf %&gt;% \n  filter(year(observation_date) &gt;= 2013, year(observation_date) &lt;= 2022,\n         protocol_type %in% c(\"Traveling\", \"Stationary\"),\n         duration_minutes &lt; 6 * 60,\n         effort_distance_km &lt; 10 | protocol_type == \"Stationary\")\nnrow(zf)\n#&gt; [1] 22838\nnrow(zf_filtered)\n#&gt; [1] 16526\n\nWe reduced the number of checklists by 6,312, but the checklists remaining are of higher quality.\nFinally, many of the columns in this data frame are unnecessary or redundant, so we’ll select only the columns we need.\n\nchecklists_zf &lt;- zf_filtered %&gt;% \n  select(checklist_id, \n         latitude, longitude,\n         observation_date, time_observations_started,\n         protocol_type,\n         duration_minutes, effort_distance_km, number_observers,\n         observation_count, species_observed)"
  },
  {
    "objectID": "ebird.html#sec-ebird-applications",
    "href": "ebird.html#sec-ebird-applications",
    "title": "1  Best Practices for using eBird Data",
    "section": "1.6 Applications",
    "text": "1.6 Applications\n\n1.6.1 Detection frequency\nThe simplest thing we can do with these eBird observations is estimate the frequency of detection of Fork-tailed Flycatcher within Rio Grande do Sul. This is the proportion of eBird checklists in the region that detected the species. species_observed is a binary TRUE/FALSE column indicating if a species was detected and R treats TRUE as 1 and FALSE as 0, so we can take the average of this column to get the detection frequency.\n\nmean(checklists_zf$species_observed)\n#&gt; [1] 0.15\n\nSo, Fork-tailed Flycatcher is fairly common within this region with 15% of checklists detecting the species. Detection frequency can be used to compare the prevalence of a species between regions or over time. For example, Fork-tailed Flycatcher is migratory, so let’s look at how detection frequency changes over the months of the year.\n\nmonthly_detection &lt;- checklists_zf %&gt;% \n  mutate(month = month(observation_date)) %&gt;% \n  group_by(month) %&gt;% \n  summarize(detection_frequency = mean(species_observed))\n\n# plot monthly detection frequency\nggplot(monthly_detection) +\n  aes(x = month, y = detection_frequency) +\n  geom_line() +\n  geom_point() +\n  scale_x_continuous(breaks = 1:12) +\n  scale_y_continuous(labels = scales::percent) +\n  labs(x = \"Month of year\",\n       y = \"Detection frequency\",\n       title = \"Monthly detection frequency for Fork-tailed Flycatcher\",\n       subtitle = \"Rio Grande do Sul, Brazil\")\n\n\n\n\n\n\n\n\nBased on this chart, Fork-tailed Flycatcher appears to arrive in Rio Grande do Sul in September and depart in February.\n\n\n\n\n\n\nExercise\n\n\n\nUse a similar technique to calculate and plot the monthly number of eBird checklists in Rio Grande do Sul. Are there differences between months? If so, what does this tell you about using number of detections from presence-only as a measure of prevalence?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nThere is significant variability in checklist submissions per month, with twice as many checklists in February as October. If we were to look at the monthly number of detections from presence-only data we would expect more detections in months with more checklists even if the prevalence of Fork-tailed Flycatcher is the same.\n\nmonthly_checklists &lt;- count(checklists_zf, month = month(observation_date))\n\n# plot monthly number of checklists\nggplot(monthly_checklists) +\n  aes(x = month, y = n) +\n  geom_line() +\n  geom_point() +\n  scale_x_continuous(breaks = 1:12) +\n  scale_y_continuous(limits = c(0, NA), labels = scales::comma) +\n  labs(x = \"Month of year\",\n       y = \"# of eBird checklists\",\n       title = \"Monthly eBird checklist submissions in Rio Grande do Sul\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n1.6.2 Converting to spatial format\nMany applications of eBird data require converting the data into an explicitly spatial format, for example, to make a map or subset the observations to only those within a polygon for a protected area. The R package sf can be use to represent spatial points, lines, and polygons in R. We can convert the data frame of checklists to an sf object using the latitude and longitude.\n\nchecklists_sf &lt;- st_as_sf(checklists_zf, coords = c(\"longitude\", \"latitude\"),\n                          # 4326 is the code for an unprojected lon/lat\n                          # coordiante reference system\n                          crs = 4326)\nprint(checklists_sf)\n#&gt; Simple feature collection with 16526 features and 9 fields\n#&gt; Geometry type: POINT\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -57.6 ymin: -35 xmax: -48.7 ymax: -27.1\n#&gt; Geodetic CRS:  WGS 84\n#&gt; # A tibble: 16,526 × 10\n#&gt;   checklist_id observation_date time_observations_started protocol_type\n#&gt; * &lt;chr&gt;        &lt;date&gt;           &lt;chr&gt;                     &lt;chr&gt;        \n#&gt; 1 S117444976   2013-05-18       07:47:00                  Traveling    \n#&gt; 2 S117215031   2013-04-14       07:53:00                  Traveling    \n#&gt; 3 S53740464    2013-01-11       08:00:00                  Traveling    \n#&gt; 4 S16023053    2013-12-14       17:30:00                  Stationary   \n#&gt; 5 S15844084    2013-12-03       13:00:00                  Traveling    \n#&gt; 6 S117214399   2013-03-16       07:36:00                  Traveling    \n#&gt; # ℹ 16,520 more rows\n#&gt; # ℹ 6 more variables: duration_minutes &lt;int&gt;, effort_distance_km &lt;dbl&gt;,\n#&gt; #   number_observers &lt;int&gt;, observation_count &lt;int&gt;, species_observed &lt;lgl&gt;,\n#&gt; #   geometry &lt;POINT [°]&gt;\n\nImagine that we’re only interested in observations from within 50 km of Gramado, Brazil (29.375°S, 50.876°W). We can use sf to generate a circle of radium 50 km centered on Gramado, then subset observations to only those falling within the circle.\n\ngramado_point &lt;- st_sfc(st_point(c(-50.876, -29.375)), crs = 4326)\n# 50km = 50,000m\ngramado_circle &lt;- st_buffer(gramado_point, dist = 50000)\nchecklists_gramado &lt;- checklists_sf[gramado_circle, ]\n\nWe could now, for example, calculate the detection frequency in the area around Gramado.\n\nmean(checklists_gramado$species_observed)\n#&gt; [1] 0.097\n\nFinally, in many cases, it may be more convenient to work with eBird data outside of R in a GIS such as QGIS, a free and open source GIS. We can export the Fork-tailed Flycatcher observations to a GeoPackage using sf.\n\nwrite_sf(checklists_sf, \"data/fotfly-ebird_br-rs.gpkg\",\n         layer = \"fotfly_observations\")\n\n\n\n\n\n\n\nTip\n\n\n\nThe GeoPackage is a modern, open source alternative to the shapefile format for storing spatial data. GeoPackages avoid many of the problems and limitations associated with shapefiles, and they are much more efficient than shapefiles. The online ArcGIS documentation provides instructions for how to open a GeoPackage in ArcGIS.\n\n\n\n\n1.6.3 Mapping\nNow that we have the data in a spatial format, we can produce a map of the Fork-tailed Flycatcher detection/non-detection data. For complex, highly customized maps, we recommend using a GIS such as QGIS that’s specifically designed for cartography. However, it is possible to make a quick, simple map in R.\nWe’ll start by loading polygons defining coutry and state borders, which will provide contextual information for our map. These polygons come from Natural Earth, and excellent source of global, attribution free spatial data. The R package rnaturalearth provides access to Natural Earth data within R; however, for convenience we’ve provided the necessary layers in the file data/gis-data.gpkg included in the data package for this workshop. We’ll also project everything to an equal area projection center on Rio Grande do Sul.\n\ncrs &lt;- st_crs(\"+proj=laea +lat_0=-30 +lon_0=-50\")\n\n# polygons from natural earth\nne_land &lt;- read_sf(\"data/gis-data.gpkg\", \"ne_land\") %&gt;% \n  st_transform(crs = crs)\nne_country_lines &lt;- read_sf(\"data/gis-data.gpkg\", \"ne_country_lines\") %&gt;% \n  st_transform(crs = crs)\nrgds_boundary &lt;- read_sf(\"data/gis-data.gpkg\", \"ne_states\") %&gt;% \n  filter(state_code == \"BR-RS\") %&gt;% \n  st_transform(crs = crs)\n\n# transform ebird data to equal area projection\nchecklists_proj &lt;- st_transform(checklists_sf, crs = crs)\n\nNow we can make a map of observations of Fork-tailed Flycatcher in Rio Grande do Sul. We build up the map in layers, first creating a basemap with the Natural Earth polygons, then plotting the eBird detection and non-detection data on top. When building up a map in layes like this, it’s often useful to first plot a blank version the main dataset you intend to map to define the spatial extent of the map, then layer everything else on top, finishing with plotting the data a second time so it appears as the top layer.\n\npar(mar = c(0.25, 0.25, 2, 0.25))\n\n# start with a blank plot of the data to define the spatial extent of the map\nplot(st_geometry(checklists_proj), col = NA)\n\n# contextual gis data\nplot(ne_land, col = \"#dddddd\", border = \"#888888\", lwd = 0.5, add = TRUE)\nplot(rgds_boundary, col = \"#cccccc\", border = NA, add = TRUE)\n#&gt; Warning in plot.sf(rgds_boundary, col = \"#cccccc\", border = NA, add = TRUE):\n#&gt; ignoring all but the first attribute\nplot(ne_country_lines, col = \"#ffffff\", lwd = 1.5, add = TRUE)\n\n# ebird observations\n# not detected\nplot(filter(checklists_proj, !species_observed),\n     pch = 19, cex = 0.2, col = alpha(\"#555555\", 0.5),\n     add = TRUE)\n#&gt; Warning in plot.sf(filter(checklists_proj, !species_observed), pch = 19, :\n#&gt; ignoring all but the first attribute\n# detected\nplot(filter(checklists_proj, species_observed),\n     pch = 19, cex = 0.3, col = alpha(\"#4daf4a\", 1),\n     add = TRUE)\n#&gt; Warning in plot.sf(filter(checklists_proj, species_observed), pch = 19, :\n#&gt; ignoring all but the first attribute\n# legend\nlegend(\"bottomright\", bty = \"n\",\n       col = c(\"#555555\", \"#4daf4a\"),\n       legend = c(\"eBird checklists\", \"Fork-tailed Flycatcher sightings\"),\n       pch = 19)\nbox()\ntitle(\"Fork-tailed Flycatcher eBird Observations (2013-2022)\")"
  },
  {
    "objectID": "ebirdst.html#sec-ebirdst-access",
    "href": "ebirdst.html#sec-ebirdst-access",
    "title": "4  Productos de Estados y Tendencias de eBird",
    "section": "",
    "text": "Checkpoint\n\n\n\nPara asegurarte de que tu clave de acceso a los datos funciona, intenta ejecutar el siguiente código, que descargará un único archivo pequeño. Si no funciona, habla con el instructor o envíanos un correo para buscar una solución al problema.\n\ndir.create(\"data/ebirdst-data\", recursive = TRUE, showWarnings = FALSE) \n\nebirdst_download_status(\"grbfir1\", pattern = \"abundance_median_3km\", path = \"data/ebirdst-data/\", force = TRUE)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Productos de Estados y Tendencias de eBird</span>"
    ]
  },
  {
    "objectID": "ebirdst.html#sec-ebirdst-species",
    "href": "ebirdst.html#sec-ebirdst-species",
    "title": "4  Productos de Estados y Tendencias de eBird",
    "section": "4.2 Especies con Estados y Tendencias",
    "text": "4.2 Especies con Estados y Tendencias\nEl objeto ebirdst_runs es un data frame que enumera todas las especies disponibles:\n\nglimpse(ebirdst_runs)\n#&gt; Rows: 2,981\n#&gt; Columns: 30\n#&gt; $ species_code                   &lt;chr&gt; \"yebsap-example\", \"abetow\", \"absfin1\", …\n#&gt; $ scientific_name                &lt;chr&gt; \"Sphyrapicus varius\", \"Melozone aberti\"…\n#&gt; $ common_name                    &lt;chr&gt; \"Yellow-bellied Sapsucker\", \"Abert's To…\n#&gt; $ is_resident                    &lt;lgl&gt; FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, F…\n#&gt; $ breeding_quality               &lt;chr&gt; \"3\", NA, NA, \"3\", NA, NA, \"1\", NA, NA, …\n#&gt; $ breeding_start                 &lt;date&gt; 2023-05-17, NA, NA, 2023-05-31, NA, NA…\n#&gt; $ breeding_end                   &lt;date&gt; 2023-08-16, NA, NA, 2023-08-02, NA, NA…\n#&gt; $ nonbreeding_quality            &lt;chr&gt; \"3\", NA, NA, \"3\", NA, NA, \"1\", NA, NA, …\n#&gt; $ nonbreeding_start              &lt;date&gt; 2023-11-22, NA, NA, 2023-11-22, NA, NA…\n#&gt; $ nonbreeding_end                &lt;date&gt; 2023-03-08, NA, NA, 2023-02-22, NA, NA…\n#&gt; $ postbreeding_migration_quality &lt;chr&gt; \"3\", NA, NA, \"3\", NA, NA, \"0\", NA, NA, …\n#&gt; $ postbreeding_migration_start   &lt;date&gt; 2023-08-23, NA, NA, 2023-08-09, NA, NA…\n#&gt; $ postbreeding_migration_end     &lt;date&gt; 2023-11-15, NA, NA, 2023-11-15, NA, NA…\n#&gt; $ prebreeding_migration_quality  &lt;chr&gt; \"3\", NA, NA, \"3\", NA, NA, \"0\", NA, NA, …\n#&gt; $ prebreeding_migration_start    &lt;date&gt; 2023-03-15, NA, NA, 2023-03-01, NA, NA…\n#&gt; $ prebreeding_migration_end      &lt;date&gt; 2023-05-10, NA, NA, 2023-05-24, NA, NA…\n#&gt; $ resident_quality               &lt;chr&gt; NA, \"3\", \"3\", NA, \"3\", \"3\", NA, \"2\", \"3…\n#&gt; $ resident_start                 &lt;date&gt; NA, 2023-01-04, 2023-01-04, NA, 2023-0…\n#&gt; $ resident_end                   &lt;date&gt; NA, 2023-12-27, 2023-12-27, NA, 2023-1…\n#&gt; $ status_version_year            &lt;dbl&gt; 2023, 2023, 2023, 2023, 2023, 2023, 202…\n#&gt; $ has_trends                     &lt;lgl&gt; TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, F…\n#&gt; $ trends_season                  &lt;chr&gt; \"breeding\", \"resident\", NA, \"breeding\",…\n#&gt; $ trends_region                  &lt;chr&gt; \"north_america\", \"north_america\", NA, \"…\n#&gt; $ trends_start_year              &lt;dbl&gt; 2012, 2012, NA, 2012, 2011, NA, NA, NA,…\n#&gt; $ trends_end_year                &lt;dbl&gt; 2022, 2022, NA, 2022, 2021, NA, NA, NA,…\n#&gt; $ trends_start_date              &lt;chr&gt; \"05-24\", \"01-25\", NA, \"05-24\", \"11-01\",…\n#&gt; $ trends_end_date                &lt;chr&gt; \"08-16\", \"05-10\", NA, \"08-02\", \"05-03\",…\n#&gt; $ rsquared                       &lt;dbl&gt; 0.857, 0.923, NA, 0.857, 0.881, NA, NA,…\n#&gt; $ beta0                          &lt;dbl&gt; 0.22700, -0.01392, NA, 0.68942, -0.0926…\n#&gt; $ trends_version_year            &lt;dbl&gt; 2022, 2022, NA, 2022, 2022, NA, NA, NA,…\n\nDesde RStudio también puedes utilizar View() para explorar de forma interactiva la base de datos. También puedes consultar la página de especies en Estados y Tendencias para ver la lista completa de especies disponibles. En esta página puedes filtrar por región, por ejemplo, para ver solo aquellas especies con alguna parte de su área de distribución dentro de Chile.\n\n4.2.1 Revisión de expertos\nTodas las especies pasan por un proceso de revisión por parte de expertos humanos antes de ser publicadas. El marco de datos «ebirdst_runs» también contiene información de este proceso de revisión. Los revisores evalúan cada una de las cuatro estaciones: reproducción, no reproducción, migración previa a la reproducción y migración posterior a la reproducción. Las especies residentes (es decir, no migratorias) se identifican con el valor «TRUE» en la columna resident column of ebirdst_runs, y estas especies se evalúan a lo largo de todo el año en lugar de por temporadas. «ebirdst_runs» contiene dos datos importantes para cada estación: una calificación de calidad (quality) y fechas estacionales (seasonal dates).\nLas seasonal dates definen las semanas que comprenden cada estación; las estimaciones de abundancia relativa para estas semanas se promedian para producir los mapas de abundancia relativa estacional en el sitio de Estados y Tendencias. Las fechas de la temporada reproductiva y no reproductiva se definen para cada especie como las semanas durante esas estaciones en las que la población de la especie no se desplaza. Por esta razón, estas estaciones también se describen como períodos estacionarios. Los períodos de migración se definen como los períodos de movimiento entre las temporadas estacionarias no reproductivas y reproductivas. Cabe señalar que, para muchas especies, estos períodos migratorios incluyen no solo el movimiento desde las zonas de reproducción a las zonas no reproductivas, sino también la dispersión posterior a la reproducción, la migración por muda y otros movimientos.\nLos revisores también examinan las estimaciones del modelo para cada temporada con el fin de evaluar el grado de extrapolación u omisión presente en el modelo, y asignan una calificación de calidad asociada que va de 0 (calidad más baja) a 3 (calidad más alta). La extrapolación se refiere a los casos en los que el modelo predice la presencia de una especie cuando se sabe que está ausente, mientras que la omisión se refiere a los casos en los que el modelo no predice la presencia de una especie cuando se sabe que está presente.\nUna calificación de 0 implica que esta temporada no ha superado la revisión y que los resultados del modelo no deben utilizarse en absoluto para este período. Las calificaciones de 1 a 3 corresponden a un gradiente de mayor a menor extrapolación y/u omisión, y a menudo utilizamos una analogía con los semáforos para referirnos a ellas:\n\nLuz roja (1): baja calidad, extrapolación y/u omisión extensas y ruido, pero al menos algunas regiones tienen estimaciones precisas; se puede utilizar con precaución en determinadas regiones.\nLuz amarilla (2): calidad media, cierta extrapolación y/u omisión; utilizar con precaución.\nLuz verde (3): calidad alta, muy poca o ninguna extrapolación y/u omisión; estas temporadas se pueden utilizar con seguridad.\n\n\n\n\n\n\n\nEjercicio\n\n\n\nElije una especie que te interese. Identifica las fechas estacionales y la calificacion de calidad.\n\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\nEl Picaflor chico está catalogado como migratorio, con una calificación de calidad de 2 en las cuatro estaciones, lo que sugiere que hay alguna extrapolación u omisión.\n\nebirdst_runs %&gt;% \n  filter(scientific_name == \"Sephanoides sephaniodes\") %&gt;% \n  glimpse()\n#&gt; Rows: 1\n#&gt; Columns: 30\n#&gt; $ species_code                   &lt;chr&gt; \"grbfir1\"\n#&gt; $ scientific_name                &lt;chr&gt; \"Sephanoides sephaniodes\"\n#&gt; $ common_name                    &lt;chr&gt; \"Green-backed Firecrown\"\n#&gt; $ is_resident                    &lt;lgl&gt; FALSE\n#&gt; $ breeding_quality               &lt;chr&gt; \"3\"\n#&gt; $ breeding_start                 &lt;date&gt; 2023-11-22\n#&gt; $ breeding_end                   &lt;date&gt; 2023-04-26\n#&gt; $ nonbreeding_quality            &lt;chr&gt; \"3\"\n#&gt; $ nonbreeding_start              &lt;date&gt; 2023-06-14\n#&gt; $ nonbreeding_end                &lt;date&gt; 2023-08-30\n#&gt; $ postbreeding_migration_quality &lt;chr&gt; \"2\"\n#&gt; $ postbreeding_migration_start   &lt;date&gt; 2023-05-03\n#&gt; $ postbreeding_migration_end     &lt;date&gt; 2023-06-07\n#&gt; $ prebreeding_migration_quality  &lt;chr&gt; \"2\"\n#&gt; $ prebreeding_migration_start    &lt;date&gt; 2023-09-06\n#&gt; $ prebreeding_migration_end      &lt;date&gt; 2023-11-15\n#&gt; $ resident_quality               &lt;chr&gt; NA\n#&gt; $ resident_start                 &lt;date&gt; NA\n#&gt; $ resident_end                   &lt;date&gt; NA\n#&gt; $ status_version_year            &lt;dbl&gt; 2023\n#&gt; $ has_trends                     &lt;lgl&gt; TRUE\n#&gt; $ trends_season                  &lt;chr&gt; \"breeding\"\n#&gt; $ trends_region                  &lt;chr&gt; \"south_america\"\n#&gt; $ trends_start_year              &lt;dbl&gt; 2014\n#&gt; $ trends_end_year                &lt;dbl&gt; 2021\n#&gt; $ trends_start_date              &lt;chr&gt; \"11-22\"\n#&gt; $ trends_end_date                &lt;chr&gt; \"04-26\"\n#&gt; $ rsquared                       &lt;dbl&gt; 0.625\n#&gt; $ beta0                          &lt;dbl&gt; -0.194\n#&gt; $ trends_version_year            &lt;dbl&gt; 2022",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Productos de Estados y Tendencias de eBird</span>"
    ]
  },
  {
    "objectID": "ebirdst.html#sec-ebirdst-download",
    "href": "ebirdst.html#sec-ebirdst-download",
    "title": "4  Productos de Estados y Tendencias de eBird",
    "section": "4.3 Descarga de datos",
    "text": "4.3 Descarga de datos\nLa función ebirdst_download_status() descarga datos de una sola especie a partir del nombre de la especie (nombre común, nombre científico o código de especie). Por ejemplo, para descargar los datos del Picaflor chico, utilice:\n\npath &lt;- ebirdst_download_status(species = \"Sephanoides sephaniodes\", path = \"data/ebirdst-data\")\npath\n\n\n#&gt; [1] \"data/ebirdst-data/2023/grbfir1\"\n\nLa función identificará automáticamente una ubicación adecuada para almacenar los datos descargados y devolverá esa ruta, que hemos capturado en la variable path. Podemos ver qué archivos se han descargado con:\n\nlist.files(path, recursive = TRUE)\n#&gt;  [1] \"config.json\"                                                       \n#&gt;  [2] \"seasonal/grbfir1_abundance_full-year_max_27km_2023.tif\"            \n#&gt;  [3] \"seasonal/grbfir1_abundance_full-year_max_3km_2023.tif\"             \n#&gt;  [4] \"seasonal/grbfir1_abundance_full-year_max_9km_2023.tif\"             \n#&gt;  [5] \"seasonal/grbfir1_abundance_full-year_mean_27km_2023.tif\"           \n#&gt;  [6] \"seasonal/grbfir1_abundance_full-year_mean_3km_2023.tif\"            \n#&gt;  [7] \"seasonal/grbfir1_abundance_full-year_mean_9km_2023.tif\"            \n#&gt;  [8] \"seasonal/grbfir1_abundance_seasonal_max_27km_2023.tif\"             \n#&gt;  [9] \"seasonal/grbfir1_abundance_seasonal_max_3km_2023.tif\"              \n#&gt; [10] \"seasonal/grbfir1_abundance_seasonal_max_9km_2023.tif\"              \n#&gt; [11] \"seasonal/grbfir1_abundance_seasonal_mean_27km_2023.tif\"            \n#&gt; [12] \"seasonal/grbfir1_abundance_seasonal_mean_3km_2023.tif\"             \n#&gt; [13] \"seasonal/grbfir1_abundance_seasonal_mean_9km_2023.tif\"             \n#&gt; [14] \"seasonal/grbfir1_proportion-population_seasonal_mean_27km_2023.tif\"\n#&gt; [15] \"seasonal/grbfir1_proportion-population_seasonal_mean_3km_2023.tif\" \n#&gt; [16] \"seasonal/grbfir1_proportion-population_seasonal_mean_9km_2023.tif\" \n#&gt; [17] \"weekly/grbfir1_abundance_lower_27km_2023.tif\"                      \n#&gt; [18] \"weekly/grbfir1_abundance_lower_3km_2023.tif\"                       \n#&gt; [19] \"weekly/grbfir1_abundance_lower_9km_2023.tif\"                       \n#&gt; [20] \"weekly/grbfir1_abundance_median_27km_2023.tif\"                     \n#&gt; [21] \"weekly/grbfir1_abundance_median_3km_2023.tif\"                      \n#&gt; [22] \"weekly/grbfir1_abundance_median_9km_2023.tif\"                      \n#&gt; [23] \"weekly/grbfir1_abundance_upper_27km_2023.tif\"                      \n#&gt; [24] \"weekly/grbfir1_abundance_upper_3km_2023.tif\"                       \n#&gt; [25] \"weekly/grbfir1_abundance_upper_9km_2023.tif\"                       \n#&gt; [26] \"weekly/grbfir1_proportion-population_median_27km_2023.tif\"         \n#&gt; [27] \"weekly/grbfir1_proportion-population_median_3km_2023.tif\"          \n#&gt; [28] \"weekly/grbfir1_proportion-population_median_9km_2023.tif\"\n\nDentro de este directorio de paquetes de datos, los archivos están organizados según la siguiente estructura:\n\nweekly/: un directorio que contiene estimaciones semanales de ocurrencia, conteo, abundancia relativa y proporción de población en una cuadrícula regular en formato GeoTIFF con tres resoluciones. Ver más abajo para obtener más detalles.\nseasonal/: un directorio que contiene estimaciones estacionales de ocurrencia, conteo, abundancia relativa y proporción de población en una cuadrícula regular en formato GeoTIFF con tres resoluciones. Estas se derivan de los datos ráster semanales correspondientes. Las fechas que definen los límites de cada estación se establecen en función de cada especie por un revisor experto familiarizado con la misma. Estas fechas están disponibles en el marco de datos ebirdst_runs. Solo se incluyen las estaciones que han superado el proceso de revisión por expertos. Ver más abajo para obtener más detalles.\nranges/: un directorio que contiene GeoPackages que almacenan polígonos de límites de distribución. Ver más abajo para obtener más detalles.\nconfig.json: parámetros específicos de la ejecución, principalmente para uso interno, pero que también contienen parámetros útiles para cartografiar los datos de abundancia.\n\n\n\n\n\n\n\nTip\n\n\n\nLos datos espaciales se dividen en dos grandes categorías: datos ráster y datos vectoriales. Los datos ráster representan los datos espaciales como una cuadrícula regular de celdas con un valor o conjunto de valores asignados a cada una. Los datos vectoriales representan los datos espaciales como puntos, líneas o polígonos discretos. En los productos de datos de eBird Status, los datos ráster se distribuyen como GeoTIFF, mientras que los datos vectoriales se distribuyen como GeoPackages.\n\n\nPara una especie cuyos datos ya se han descargado, puede utilizar get_species_path(\"Sephanoides sephaniodes\") para identificar la ruta de acceso a los datos.\n\n4.3.1 Descarga de archivos específicos\nEl paquete completo de datos de cada especie contiene un gran número de archivos, muchos de los cuales pueden ser innecesarios para su aplicación. Puede utilizar el argumento dry_run = TRUE en ebirdst_download() para obtener una lista de los archivos disponibles sin descargarlos.\n\nebirdst_download_status(\"Sephanoides sephaniodes\", dry_run = TRUE)\n\nUna vez identificados los archivos que desea, puede utilizar el argumento pattern para descargar solo esos archivos. Por ejemplo, imaginemos que solo queremos los archivos abundance:\n\nebirdst_download_status(\"Sephanoides sephaniodes\", pattern = \"abundance\", path = \"data/ebirdst-data/\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Productos de Estados y Tendencias de eBird</span>"
    ]
  },
  {
    "objectID": "ebirdst.html#sec-ebirdst-load",
    "href": "ebirdst.html#sec-ebirdst-load",
    "title": "4  Productos de Estados y Tendencias de eBird",
    "section": "4.4 Cargando datos en R",
    "text": "4.4 Cargando datos en R\nEn este curso, nos centraremos en los productos de datos ráster, que se pueden cargar en R utilizando la función load_raster() de ebirdst. En R, utilizaremos el paquete terra para trabajar con datos ráster. Los productos de datos ráster se dividen en dos grandes categorías que proporcionan estimaciones semanales y estacionales.\n\n4.4.1 Estimaciones semanales ráster\nLos productos básicos de datos ráster son las estimaciones semanales de presencia, conteo, abundancia relativa y proporción de población. Todas las estimaciones son el valor medio esperado para un listado con desplazamiento de eBird de 1 km y 1 hora realizado por un observador experto en el momento óptimo del día y en las condiciones meteorológicas óptimas para observar la especie en cuestión.\n\nOcurrencia occurrence: la probabilidad esperada de encontrar una especie.\nConteo count: el conteo esperado de una especie, condicionado a su ocurrencia en la ubicación dada.\nAbundancia relativa abundance: la abundancia relativa esperada de una especie, calculada como el producto de la probabilidad de ocurrencia y el conteo condicionado a la ocurrencia. Además de la abundancia relativa mediana, se proporcionan intervalos de confianza (IC) superiores e inferiores, definidos en el decil 10 y el decil 90 de la abundancia relativa, respectivamente.\nProporción de población proportion-population: la proporción de la abundancia relativa total dentro de cada celda. Se trata de un producto derivado que se calcula dividiendo cada valor de celda de abundancia relativa del ráster por la suma de todos los valores de celda.\n\nTodas las predicciones se realizan en una cuadrícula global estándar de 2,96 km x 2,96 km; sin embargo, también se proporcionan archivos GeoTIFF de menor resolución, que suelen ser mucho más rápidos de manejar. Las tres resoluciones son:\n\nAlta resolución (3km): datos con una resolución nativa de 2,96 km.\nResolución media (9km): datos 3km agregados por un factor de 3 en cada dirección, lo que da como resultado una resolución de 8,89 km.\nBaja resolución (27km): datos 3km agregados por un factor de 9 en cada dirección, lo que da como resultado una resolución de 26,7 km.\n\nLos archivos semanales utilizan la siguiente convención de nomenclatura:\nweekly/&lt;species_code&gt;_&lt;product&gt;_&lt;metric&gt;_&lt;resolution&gt;_&lt;year&gt;.tif\ndonde metric suele ser median, excepto en los IC de abundancia relativa, que utilizan lower y upper. La función load_raster() se utiliza para cargar estos datos en R y toma argumentos para product, metric y resolution. Por ejemplo, para cargar la abundancia relativa mediana de alta resolución, utilice:\n\nabd_median_3km &lt;- load_raster(species = \"grbfir1\", \n                              path = \"data/ebirdst-data/\", \n                              product = \"abundance\", \n                              period = \"weekly\", \n                              metric = \"median\", \n                              resolution = \"3km\")\nprint(abd_median_3km)\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 5562, 11484, 52  (nrow, ncol, nlyr)\n#&gt; resolution  : 3000, 3000  (x, y)\n#&gt; extent      : -17226000, 17226000, -8343000, 8343000  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : WGS 84 / Equal Earth Greenwich (EPSG:8857) \n#&gt; source      : grbfir1_abundance_median_3km_2023.tif \n#&gt; names       : 2023-01-04, 2023-01-11, 2023-01-18, 2023-01-25, 2023-02-01, 2023-02-08, ... \n#&gt; min values  :       0.00,       0.00,       0.00,        0.0,       0.00,       0.00, ... \n#&gt; max values  :       4.09,       4.97,       4.53,        3.9,       3.76,       4.41, ...\n\nA menudo nos referimos a estos objetos ráster como cubos semanales (por ejemplo, el cubo de abundancia semanal). Obsérvese que los cubos contienen 52 capas, que corresponden a las semanas del año. Los nombres de las capas son las fechas asociadas al punto medio de cada semana.\n\nas.Date(names(abd_median_3km))\n#&gt;  [1] \"2023-01-04\" \"2023-01-11\" \"2023-01-18\" \"2023-01-25\" \"2023-02-01\"\n#&gt;  [6] \"2023-02-08\" \"2023-02-15\" \"2023-02-22\" \"2023-03-01\" \"2023-03-08\"\n#&gt; [11] \"2023-03-15\" \"2023-03-22\" \"2023-03-29\" \"2023-04-05\" \"2023-04-12\"\n#&gt; [16] \"2023-04-19\" \"2023-04-26\" \"2023-05-03\" \"2023-05-10\" \"2023-05-17\"\n#&gt; [21] \"2023-05-24\" \"2023-05-31\" \"2023-06-07\" \"2023-06-14\" \"2023-06-21\"\n#&gt; [26] \"2023-06-28\" \"2023-07-05\" \"2023-07-12\" \"2023-07-19\" \"2023-07-26\"\n#&gt; [31] \"2023-08-02\" \"2023-08-09\" \"2023-08-16\" \"2023-08-23\" \"2023-08-30\"\n#&gt; [36] \"2023-09-06\" \"2023-09-13\" \"2023-09-20\" \"2023-09-27\" \"2023-10-04\"\n#&gt; [41] \"2023-10-11\" \"2023-10-18\" \"2023-10-25\" \"2023-11-01\" \"2023-11-08\"\n#&gt; [46] \"2023-11-15\" \"2023-11-22\" \"2023-11-29\" \"2023-12-06\" \"2023-12-13\"\n#&gt; [51] \"2023-12-20\" \"2023-12-27\"\n\nComo otro ejemplo, podríamos cargar los intervalos de confianza de abundancia superior e inferior de baja resolución.\n\nabd_lower_27km &lt;- load_raster(species = \"grbfir1\", \n                              path = \"data/ebirdst-data/\",\n                              product = \"abundance\", \n                              metric = \"lower\", \n                              period = \"weekly\",\n                              resolution = \"27km\")\n\nabd_upper_27km &lt;- load_raster(species = \"grbfir1\", \n                              path = \"data/ebirdst-data/\",\n                              product = \"abundance\", \n                              metric = \"upper\", \n                              period = \"weekly\",\n                              resolution = \"27km\")\n\n\n\n\n\n\n\nEjercicio\n\n\n\nIntente cargar el cubo del porcentaje medio semanal de la población con una resolución media.\n\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\npct_pop &lt;- load_raster(species = \"grbfir1\", \n                       path = \"data/ebirdst-data/\",\n                       product = \"proportion-population\", \n                       metric = \"median\", \n                       resolution = \"9km\")\nprint(pct_pop)\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 1854, 3828, 52  (nrow, ncol, nlyr)\n#&gt; resolution  : 9000, 9000  (x, y)\n#&gt; extent      : -17226000, 17226000, -8343000, 8343000  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : WGS 84 / Equal Earth Greenwich (EPSG:8857) \n#&gt; source      : grbfir1_proportion-population_median_9km_2023.tif \n#&gt; names       : 2023-01-04, 2023-01-11, 2023-01-18, 2023-01-25, 2023-02-01, 2023-02-08, ... \n#&gt; min values  :    0.00000,    0.00000,     0.0000,    0.00000,   0.000000,   0.000000, ... \n#&gt; max values  :    0.00115,    0.00122,     0.0012,    0.00101,   0.000919,   0.000875, ...\n\n\n\n\n\n\n4.4.2 Rásters de estimaciones estacionales\nLos rásters de estimaciones estacionales se proporcionan para el mismo conjunto de productos y con las mismas tres resoluciones que las estimaciones semanales. Se obtienen a partir de los datos semanales tomando la media o el máximo por celda a lo largo de las semanas de cada estación. Recuerde que las fechas límite estacionales están disponibles en ebirdst_runs; no se proporcionan datos para las estaciones con una puntuación de calidad de 0.\nLos GeoTIFF estacionales utilizan la siguiente convención de nomenclatura:\nseasonal/&lt;species_code&gt;_&lt;product&gt;_seasonal_&lt;metric&gt;_&lt;resolution&gt;_&lt;year&gt;.tif\ndonde metric es mean o max. La función load_raster(period = \"seasonal\") se utiliza para cargar estos datos en R y toma argumentos para product, metric y resolution. Por ejemplo, para cargar la abundancia relativa estacional media de baja resolución, utilice:\n\nabd_seasonal_mean &lt;- load_raster(species = \"grbfir1\", \n                                 path = \"data/ebirdst-data/\",\n                                 product = \"abundance\", \n                                 period = \"seasonal\", \n                                 metric = \"mean\", \n                                 resolution = \"27km\")\nprint(abd_seasonal_mean)\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 618, 1276, 4  (nrow, ncol, nlyr)\n#&gt; resolution  : 27000, 27000  (x, y)\n#&gt; extent      : -17226000, 17226000, -8343000, 8343000  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : WGS 84 / Equal Earth Greenwich (EPSG:8857) \n#&gt; source      : grbfir1_abundance_seasonal_mean_27km_2023.tif \n#&gt; names       : breeding, nonbreeding, prebree~gration, postbre~gration \n#&gt; min values  :     0.00,        0.00,            0.00,             0.0 \n#&gt; max values  :     3.28,        4.89,            2.47,             5.3\n\nObserve que hay cuatro capas en este ráster que corresponden a las cuatro estaciones.\n\nnames(abd_seasonal_mean)\n#&gt; [1] \"breeding\"               \"nonbreeding\"            \"prebreeding_migration\" \n#&gt; [4] \"postbreeding_migration\"\n\nPor último, para mayor comodidad, los productos de datos incluyen rásteres anuales que resumen la media o el máximo de todas las semanas que caen dentro de una estación que ha superado el proceso de revisión por expertos. Se puede acceder a ellos de forma similar a los productos estacionales, solo que con «period = “full-year”» en lugar de «period = “week”». Por ejemplo, estas capas se pueden utilizar en la planificación de la conservación para evaluar los sitios más importantes en todo el área de distribución y el ciclo anual completo de una especie.\n\nabd_fy_max &lt;- load_raster(species = \"grbfir1\",  \n                          path = \"data/ebirdst-data/\", \n                          product = \"abundance\", \n                          period = \"full-year\", \n                          metric = \"max\", \n                          resolution = \"3km\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Productos de Estados y Tendencias de eBird</span>"
    ]
  },
  {
    "objectID": "ebirdst.html#sec-ebirdst-explore",
    "href": "ebirdst.html#sec-ebirdst-explore",
    "title": "4  Productos de Estados y Tendencias de eBird",
    "section": "4.5 Explorando los datos ráster",
    "text": "4.5 Explorando los datos ráster\nCarguemos los ráster de abundancia relativa semanal y estacional de baja resolución y utilicémoslos para demostrar algunas operaciones ráster básicas con los datos.\n\nabd_weekly &lt;- load_raster(species = \"grbfir1\",  \n                          path = \"data/ebirdst-data/\",\n                          product = \"abundance\", \n                          resolution = \"27km\")\n\nabd_seasonal &lt;- load_raster(species = \"grbfir1\",  \n                            path = \"data/ebirdst-data/\", \n                            product = \"abundance\", \n                            period = \"seasonal\", \n                            resolution = \"27km\")\n\nEstos ráster se pueden dividir fácilmente en subconjuntos de una sola semana o temporada.\n\n# week of may 17\nabd_weekly[[\"2023-05-17\"]]\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 618, 1276, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 27000, 27000  (x, y)\n#&gt; extent      : -17226000, 17226000, -8343000, 8343000  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : WGS 84 / Equal Earth Greenwich (EPSG:8857) \n#&gt; source      : grbfir1_abundance_median_27km_2023.tif \n#&gt; name        : 2023-05-17 \n#&gt; min value   :       0.00 \n#&gt; max value   :       5.49\n\n# breeding season\nabd_seasonal[[\"breeding\"]]\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 618, 1276, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 27000, 27000  (x, y)\n#&gt; extent      : -17226000, 17226000, -8343000, 8343000  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : WGS 84 / Equal Earth Greenwich (EPSG:8857) \n#&gt; source      : grbfir1_abundance_seasonal_mean_27km_2023.tif \n#&gt; name        : breeding \n#&gt; min value   :     0.00 \n#&gt; max value   :     3.28\n\nTambién podemos dividir el ráster semanal en un rango de semanas. Por ejemplo, dividamos solo las estimaciones de las semanas de mayo y luego calculemos el promedio de todas las semanas.\n\n# determine qué fechas podemos incluir\nweek_dates &lt;- as.Date(names(abd_weekly))\nstart_date &lt;- as.Date(\"2023-05-01\")\nend_date &lt;- as.Date(\"2023-05-31\")\nweek_in_may &lt;- week_dates &gt;= start_date & week_dates &lt;= end_date\n\n# subset a las semanas de mayo\nabd_weekly_may &lt;- abd_weekly[[week_in_may]]\n\n# promedio semanal\nmean(abd_weekly_may, na.rm = TRUE)\n#&gt; class       : SpatRaster \n#&gt; dimensions  : 618, 1276, 1  (nrow, ncol, nlyr)\n#&gt; resolution  : 27000, 27000  (x, y)\n#&gt; extent      : -17226000, 17226000, -8343000, 8343000  (xmin, xmax, ymin, ymax)\n#&gt; coord. ref. : WGS 84 / Equal Earth Greenwich (EPSG:8857) \n#&gt; source(s)   : memory\n#&gt; name        : mean \n#&gt; min value   : 0.00 \n#&gt; max value   : 5.34\n\nCrear un mapa sencillo con los datos producirá resultados inesperados. Por ejemplo, vamos a trazar un mapa de la abundancia relativa durante la temporada de reproducción del Picaflro chico.\n\nplot(abd_seasonal[[\"breeding\"]])\n\n\n\n\n\n\n\n\nRecuerda que todos los productos de datos de eBird Status se proporcionan para todo el mundo, independientemente del área de distribución de las especies. Además, tenga en cuenta que algunas zonas, como la mayor parte de la cuenca del Amazonas, tienen valores faltantes, lo que indica que no se disponía de datos suficientes para hacer una predicción en la región. Otras zonas, como América del Norte, contaban con datos suficientes para predecir que la especie está ausente. Probemos a utilizar los datos SIG incluidos en el paquete de datos del curso para recortar el ráster a la región de Los Lagos y crear un mapa más significativo.\n\n# Límite de Los Lagos, proyectado para coincidir con los datos ráster.\nlos_lagos &lt;- read_sf(\"data/gis-data.gpkg\",  layer = \"ne_states\") %&gt;% \n  filter(state == \"Los Lagos\") %&gt;% \n  st_transform(crs = crs(abd_seasonal)) %&gt;% \n  st_geometry()\n\n# Recortar datos ráster a Chile\nabd_breeding_ll &lt;- crop(abd_seasonal[[\"breeding\"]], los_lagos)\n\n# mapear\nplot(abd_breeding_ll)\nplot(los_lagos, add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCheckpoint\n\n\n\nHagamos una pausa antes de continuar con algunas aplicaciones más realistas de los productos de datos de eBird Status. Asegúrate de que te sientes cómodo cargando los datos en R y realizando algunas de las operaciones básicas.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Productos de Estados y Tendencias de eBird</span>"
    ]
  },
  {
    "objectID": "ebirdst.html#sec-ebirdst-applications",
    "href": "ebirdst.html#sec-ebirdst-applications",
    "title": "4  Productos de Estados y Tendencias de eBird",
    "section": "4.6 Aplicaciones de productos S&T",
    "text": "4.6 Aplicaciones de productos S&T\nAhora trabajaremos algunos ejemplos de aplicaciones prácticas utilizando los productos de Estados y Tendencias.\n\nTrayectorias: visualiza el cambio en la proporción de la población de un grupo de especies en una región determinada a lo largo del año.\nEstadísticas regionales: calcula la proporción de la población reproductiva presente en áreas protegidas para un grupo de especies.\nPriorización: us los productos de Estados para identificas áreas de importancia para la protección de un grupo de especies.\n\n\n4.6.1 Trayectorias\nEn este ejercicio, analizaremos el cambio en las poblaciones de dos especies a lo largo del año en la región de Los Lagos. Consideraremos el Picaflor chico y la Viudita, dos especies migratorias que son casi endémicas de Chile. Al comparar varias especies, o una sola especie entre diferentes estaciones, como es el caso aquí, es importante tener en cuenta la proporción de la población en lugar de la abundancia relativa para mitigar el impacto de las diferencias en la detectabilidad entre estaciones y especies.\nComencemos cargando los datos de proporción de población semanal de resolución media para estas especies, así como un polígono límite para Los Lagos.\n\n# datos de proporción de la población\npop_grbfir1 &lt;- load_raster(species = \"grbfir1\", \n                       path = \"data/ebirdst-data/\",\n                       product = \"proportion-population\", \n                       metric = \"median\", \n                       resolution = \"9km\")\n\n\nebirdst_download_status(\"Patagonian Tyrant\", path = \"data/ebirdst-data/\")\n\npop_pattyr2 &lt;- load_raster(species = \"pattyr2\", \n                       path = \"data/ebirdst-data/\",\n                       product = \"proportion-population\", \n                       metric = \"median\", \n                       resolution = \"9km\")\n\n# límite de Los Lagos proyectado a la misma proyección de los datos ráster\nlos_lagos &lt;- read_sf(\"data/gis-data.gpkg\", \"ne_states\") %&gt;% \n  filter(state == \"Los Lagos\") %&gt;% \n  st_transform(crs = crs(pop_grbfir1)) %&gt;% \n  st_geometry()\n\nAhora utilizaremos el paquete exactextractr para calcular la suma de las proporciones de cada especies en Los Lagos.\n\n# suma dentro de los lagos\n# picaflor chico\ntray_grbfir1 &lt;- exact_extract(pop_grbfir1, los_lagos, fun = \"sum\")\ntray_grbfir1 &lt;- data.frame(species = \"Green-backed Firecrown\",\n                           week = as.Date(names(pop_grbfir1)),\n                           prop_pop = as.numeric(tray_grbfir1[1, ]))\n# viudita\ntray_pattyr2 &lt;- exact_extract(pop_pattyr2, los_lagos, fun = \"sum\")\ntray_pattyr2 &lt;- data.frame(species = \"Patagonian Tyrant\",\n                           week = as.Date(names(pop_pattyr2)),\n                           prop_pop = as.numeric(tray_pattyr2[1, ]))\n\n# combinar\ntrayectorias &lt;- bind_rows(tray_grbfir1, tray_pattyr2)\nhead(trayectorias)\n#&gt;                  species       week prop_pop\n#&gt; 1 Green-backed Firecrown 2023-01-04    0.244\n#&gt; 2 Green-backed Firecrown 2023-01-11    0.230\n#&gt; 3 Green-backed Firecrown 2023-01-18    0.256\n#&gt; 4 Green-backed Firecrown 2023-01-25    0.244\n#&gt; 5 Green-backed Firecrown 2023-02-01    0.243\n#&gt; 6 Green-backed Firecrown 2023-02-08    0.238\n\nFinally we can plot the trajectories.\n\nggplot(trayectorias, aes(x = week, y = prop_pop, color = species)) +\n  geom_line() +\n  scale_y_continuous(labels = scales::percent) +\n  labs(x = \"Semana\", \n       y = \"% de población\",\n       title = \"Trayectorias de % semanal de la proporción de la población en Los Lagos\",\n       color = NULL) +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n\n4.6.2 Estadísticas regionales\nPara este ejercicio calcularemos la proporción de la población dentro de areas protegidas en Chile para un grupo de especies. Como un ejemplo de grupo de especies usaremos 10 especies endémicas o casi endémicas de Chile. Para las especies que sean migratorias nos enfocaremos en la temporada reproductiva.\n\nlista_especies &lt;- c(\"cthhue1\", \"chipig2\", \"chimoc1\", \"crachi1\", \"chutap1\", \n                  \"slbpar1\", \"chitin1\", \"whttap1\", \"moutur1\", \"dutcan1\")\n\n# descargar datos para el grupo de especies\nfor (i in 1:length(lista_especies)){\n  ebirdst_download_status(lista_especies[i], path = \"data/ebirdst-data/\", pattern = \"proportion-population_seasonal_mean_9km\")\n}\n\n# agregar nombre común, residente/migratoria y calidad\nlista_especies &lt;- filter(ebirdst_runs, species_code %in% lista_especies) %&gt;% \n  mutate(quality = ifelse(is_resident, resident_quality, breeding_quality)) %&gt;% \n  dplyr::select(species_code, common_name, is_resident, quality)\nprint(lista_especies)\n#&gt; # A tibble: 10 × 4\n#&gt;   species_code common_name                 is_resident quality\n#&gt;   &lt;chr&gt;        &lt;chr&gt;                       &lt;lgl&gt;       &lt;chr&gt;  \n#&gt; 1 chimoc1      Chilean Mockingbird         TRUE        3      \n#&gt; 2 chipig2      Chilean Pigeon              FALSE       3      \n#&gt; 3 chitin1      Chilean Tinamou             TRUE        3      \n#&gt; 4 chutap1      Chucao Tapaculo             TRUE        3      \n#&gt; 5 crachi1      Crag Chilia                 TRUE        2      \n#&gt; 6 cthhue1      Chestnut-throated Huet-huet TRUE        2      \n#&gt; # ℹ 4 more rows\n\nTenemos dos especies migratorias y ocho residentes. Observe que 0 de estas especies tienen una calificación de calidad de 1, lo que indica que se debe tener precaución al utilizar los resultados. Para su uso en el mundo real, debe examinar los mapas de abundancia relativa en busca de errores antes de utilizarlos para el análisis; sin embargo, para este ejemplo, utilizaremos esta lista de especies tal cual. Cargaremos y combinaremos los porcentajes de población reproductora (para las migratorias) y residente (para las residentes) de esta lista de especies.\n\n\n\n\n\n\nTip\n\n\n\nLas estimaciones de abundancia relativa se ven afectadas por las tasas de detección, que pueden variar entre especies. Por lo tanto, al comparar los datos entre especies, es fundamental utilizar siempre las capas de proporción de población, que se han estandarizado dividiendo el valor de cada celda por la abundancia relativa total de todas las celdas.\n\n\n\n# loop over the species list extracting the seasonal percent of population\nproporcion_poblacion &lt;- list()\nfor (i in seq_len(nrow(lista_especies))) {\n  # load the seasonal cube for this species\n  this_species &lt;- lista_especies[i, ]\n  pop &lt;- load_raster(this_species$species_code, \n                     path = \"data/ebirdst-data\", \n                     product = \"proportion-population\", \n                     period = \"seasonal\",\n                     resolution = \"9km\")\n  \n  # subset to the layer we need: breeding or resident\n  pop &lt;- pop[[ifelse(this_species$is_resident, \"resident\", \"breeding\")]]\n  proporcion_poblacion[[this_species$species_code]] &lt;- pop\n}\n# stack the rasters into a single object\nproporcion_poblacion &lt;- rast(proporcion_poblacion)\n\nLos datos SIG disponibles en el paquete de datos del taller contienen límites poligonales de las áreas protegidas públicas de Chile. Vamos a cargarlos ahora y proyectarlos para que coincidan con las capas ráster. Para este ejemplo, combinaremos todos los polígonos de las áreas protegidas en una sola característica; sin embargo, este análisis podría modificarse para tener en cuenta cómo varía la distribución de las especies entre las áreas protegidas.\n\nprotegido &lt;- read_sf(\"data/gis-data.gpkg\",  layer = \"protected_areas\") %&gt;% \n  st_combine() %&gt;% \n  st_transform(crs = crs(proporcion_poblacion))\n\nFinally, we can use exactextracr to calculate the total percent of population within protected areas for each species.\n\nporcentaje_protegido &lt;- exact_extract(proporcion_poblacion, protegido, fun = \"sum\")\nporcentaje_protegido &lt;- as.numeric(porcentaje_protegido[1, ])\nporcentaje_protegido &lt;- data.frame(species_code = lista_especies$species_code,\n                                common_name = lista_especies$common_name,\n                                proporcion_poblacion = porcentaje_protegido) %&gt;% \n  arrange(desc(proporcion_poblacion))\nprint(porcentaje_protegido)\n#&gt;    species_code                 common_name proporcion_poblacion\n#&gt; 1       chutap1             Chucao Tapaculo              0.16700\n#&gt; 2       chipig2              Chilean Pigeon              0.06149\n#&gt; 3       cthhue1 Chestnut-throated Huet-huet              0.02409\n#&gt; 4       whttap1     White-throated Tapaculo              0.01827\n#&gt; 5       moutur1            Moustached Turca              0.01618\n#&gt; 6       dutcan1      Dusky-tailed Canastero              0.01558\n#&gt; 7       slbpar1     Slender-billed Parakeet              0.01450\n#&gt; 8       crachi1                 Crag Chilia              0.01301\n#&gt; 9       chimoc1         Chilean Mockingbird              0.00794\n#&gt; 10      chitin1             Chilean Tinamou              0.00696\n\n# plotear los datos\nggplot(porcentaje_protegido) +\n  aes(x = fct_reorder(common_name, proporcion_poblacion),\n      y = proporcion_poblacion) +\n  geom_col() +\n  scale_y_continuous(labels = scales::percent) +\n  labs(x = NULL, y = \"Proporción de la población en áreas protegidas\") +\n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n4.6.3 Priorización\nPara el ejercicio final, realizaremos una priorización de sitios multiespecíficos, identificando sitios importantes para proteger el conjunto de 10 especies casi endémicas que identificamos en el ejercicio anterior. Comencemos por generar una capa de importancia multiespecífica calculando el porcentaje medio de población de las 10 especies. Dado que nos centramos en identificar sitios en Chile, también recortaremos y enmascararemos la capa de importancia dentro de los límites de Chile.\n\n# límite territorio chileno\nchile &lt;- read_sf(\"data/gis-data.gpkg\", layer = \"ne_states\") %&gt;% \n  filter(country_code == \"CL\") %&gt;% \n  st_transform(crs = crs(proporcion_poblacion))\n\n# importancia: porcentaje promedio de proporción de la población entre especies\n# rellenar valores faltantes con ceros antes de promediar \nimportancia &lt;- ifel(is.na(proporcion_poblacion), 0, proporcion_poblacion) %&gt;% \n  mean(na.rm = TRUE) %&gt;% \n  # recortar y enmascarar a límite chileno\n  crop(chile) %&gt;% \n  mask(chile)\n#&gt; \n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n|---------|---------|---------|---------|\n=========================================\n                                          \n\n# plotear la raíz cuadrada de la importancia, ya que los datos están sesgados hacia la derecha.\npar(mar = c(0.25, 0.25, 0.25, 0.25))\ncrs &lt;- \"+proj=laea +lat_0=-40 +lon_0=-72\"\nr_plot &lt;- sqrt(importancia) %&gt;% \n  project(crs, method = \"near\") %&gt;% \n  trim()\nplot(r_plot, axes = FALSE)\n\n\n\n\n\n\n\n\nLos números absolutos de este mapa son difíciles de interpretar (son la proporción media de la población de las 10 especies en cada celda). En cambio, los valores deben interpretarse en términos relativos, dando la importancia relativa de cada celda para este conjunto de 10 especies.\nEn la aplicación anterior, examinamos las áreas protegidas públicas existentes. Para efectos comparativos, imaginemos que queremos identificar los sitios más importantes de Chile que cubren la misma superficie que la red de áreas protegidas existente. ¿Qué proporción de Chile cubre la red actual de áreas protegidas?\n\n# proporción de Chile en red existente de áreas protegidas\narea_chile &lt;- sum(st_area(chile))\narea_protegida &lt;- st_area(protegido)\nproporcion_protegido &lt;- as.numeric(area_protegida / area_chile)\nprint(proporcion_protegido)\n#&gt; [1] 0.208\n\nEntonces, 20.8% de Chile está cubierto por la red existente de áreas protegidas públicas. Identifiquemos el 20.8% de celdas más importantes desde la capa de importancia multiespecies.\n\n# indentificar el quantil correspondiente al nivel de protección deseado\nq &lt;- global(importancia, fun = quantile, \n            probs = 1 - proporcion_protegido, na.rm = TRUE) %&gt;% \n  as.numeric()\n# identificar las celdas más importantes\nsitios_seleccionados &lt;- as.numeric(importancia &gt;= q)\n\nComparemos loa mapas de la red existente de áreas protegidas y las seleccionadas usando Estados y Tendencias.\n\npar(mar = c(0.25, 0.25, 0.25, 0.25))\n\n# importancia alta\nr_plot &lt;- project(sitios_seleccionados, crs, method = \"near\") %&gt;% \n  trim()\nproy_protegido &lt;- st_transform(protegido, crs = crs) %&gt;% \n  st_geometry()\nplot(r_plot, axes = FALSE, legend = FALSE)\n\n# existente\nplot(st_simplify(proy_protegido), \n     col = \"grey50\", border = NA,\n     add = TRUE)\n\n\n\n\n\n\n\n\nLos sitios de alta importancia que identificamos se muestran en verde, mientras que la red de áreas protegidas existente se superpone en gris. Vemos que la red de áreas protegidas existente se encuentra principalmente en el sur de Chile y que hay una superposición limitada con las áreas de alta importancia para las 10 especies casi endémicas en las que decidimos centrarnos. Esto no es sorprendente, ya que la ubicación de las áreas protegidas existentes no se eligió específicamente para proteger estas 10 especies. Cuantifiquemos qué proporción de la población capturan estas dos regiones.\n\n# enmascarar las capas de proporción de población por los sitios seleccionados\npp_seleccionados &lt;- proporcion_poblacion %&gt;% \n  crop(sitios_seleccionados) %&gt;% \n  mask(sitios_seleccionados, maskvalues = c(0, NA))\n\n# calcular el porcentaje total de población dentro de los sitios propuestos\nporcentaje_seleccionados &lt;- global(pp_seleccionados, fun = \"sum\", na.rm = TRUE)\nporcentaje_seleccionados &lt;- data.frame(species_code = names(pp_seleccionados),\n                               porcentaje_seleccionados = porcentaje_seleccionados[, 1])\n\n# combinar con los valores de la red existente\ncomparasion &lt;- inner_join(porcentaje_protegido, porcentaje_seleccionados,\n                         by = \"species_code\") %&gt;% \n  rename(existing_network = proporcion_poblacion,\n         prioritized_sites = porcentaje_seleccionados) %&gt;% \n  pivot_longer(cols = c(existing_network, prioritized_sites),\n               names_to = \"network_type\",\n               values_to = \"proporcion_poblacion\")\n\nggplot(comparasion) +\n  aes(x = fct_reorder(common_name, proporcion_poblacion, .fun = max),\n      y = proporcion_poblacion,\n      group = network_type,\n      fill = network_type) +\n  geom_col(position = \"dodge\") +\n  scale_y_continuous(labels = scales::percent) +\n  scale_fill_brewer(palette = \"Set1\") +\n  labs(x = NULL, \n       y = \"Proporción de población en áreas protegidas\",\n       fill = NULL) +\n  coord_flip() +\n  theme_linedraw() +\n  theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nPor lo tanto, para una misma superficie total, podríamos capturar una proporción mucho mayor de las poblaciones de estas especies si utilizáramos los productos de datos de eBird Status para estas especies en nuestra priorización de sitios. Por supuesto, este ejemplo es demasiado simplista. Por ejemplo, en una aplicación real, los diferentes sitios tienen diferentes costos asociados a la protección y habría que tenerlo en cuenta a la hora de establecer las prioridades. Para problemas de priorización más complejos, se pueden utilizar eficazmente herramientas de planificación sistemática de la conservación, como el paquete R prioritizr, junto con los productos de datos de Estados de eBird.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Productos de Estados y Tendencias de eBird</span>"
    ]
  },
  {
    "objectID": "intror.html",
    "href": "intror.html",
    "title": "1  Introducción al entorno R en el contexto de eBird",
    "section": "",
    "text": "1.1 Introducción\nA lo largo de los ejercicios de este curso dejaremos explicaciones de las funciones utilizadas, pero si buscas profundizar en el uso de Tidyverse te recomendamos el libro en línea R for Data Science by Hadley Wickham.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción al entorno R en el contexto de eBird</span>"
    ]
  },
  {
    "objectID": "distabund.html",
    "href": "distabund.html",
    "title": "3  Modelamiento de distribución y abundancia relativa",
    "section": "",
    "text": "3.1 Introduction",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Modelamiento de distribución y abundancia relativa</span>"
    ]
  },
  {
    "objectID": "ebirdst.html",
    "href": "ebirdst.html",
    "title": "4  Productos de Estados y Tendencias de eBird",
    "section": "",
    "text": "4.1 Data access\nEl proyecto Estados y Tendencias utiliza modelos de machine learning de ciclo anual completo que combinan datos de eBird con datos de teledetección y toman en cuenta las variaciones en el comportamiento y el esfuerzo de los observadores para producir estimaciones semanales de alta resolución de los límites de distribución, la tasa de ocurrencia y la abundancia relativa de las especies de aves. La última versión, con estimaciones hasta el año 2023, incluye resultados para 2981 especies en todo el mundo, de las cuales 471 han sido registradas en Chile. Las visualizaciones interactivas de estas especies están disponibles en el sitio web de eBird Estados y Tendencias y los productos de datos de Estados y Tendencias de eBird están disponibles a través del paquete de R ebirdst.\nEn este modulo nos familiarizaremos con los productos de datos de Estados y Tendencias de eBird y el paquete R ebirdst, desarrollado específicamente para trabajar con estos datos. Presentaremos la gama de datos disponibles y, a continuación, les mostraremos cómo descargar estos productos de datos y cargarlos en R para su posterior análisis. Luego, trabajaremos con una serie de ejemplos de aplicaciones prácticas. Comencemos cargando los paquetes que utilizaremos a lo largo de este taller.\nEl acceso a los productos de Estados y Tendencias de eBird se obtiene mediante un formulario de solicitud de acceso disponible en: https://ebird.org/st/request. Las condiciones de uso se han diseñado para ser bastante permisivas en muchos casos, especialmente en lo que respecta al uso académico y de investigación. Después de leer las Condiciones de uso de los productos de estado y tendencias de eBird y rellenar el Formulario de solicitud de acceso, se le proporcionará una clave de acceso alfanumérica. Para almacenar la clave de acceso de modo que R y el paquete ebirdst puedan acceder a ella, ejecute lo siguiente (sustituyendo \"XXXXXXXXX\" por su clave real):\nset_ebirdst_access_key(\"fvlcg6pt15cs\", overwrite = TRUE)\nA continuación, reinicie R inmediatamente. Esto guardará la clave de acceso como variable de entorno EBIRDST_KEY en su archivo .Renviron, de modo que pueda acceder a ella desde su sesión de R.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Productos de Estados y Tendencias de eBird</span>"
    ]
  },
  {
    "objectID": "intror.html#sec-intro-tidyverse",
    "href": "intror.html#sec-intro-tidyverse",
    "title": "1  Introducción al entorno R en el contexto de eBird",
    "section": "1.2 Tidyverse",
    "text": "1.2 Tidyverse\nEn el curso utilizaremos paquetes del Tidyverse, una colección de paquetes de R diseñados para el análisis de datos. Paquetes como ggplot2 (para visualización de datos) y dplyr (para manipulación de datos), son algunos de los más conocidos de la colección.\nUno de los elementos del Tidyverse que utilizaremos bastante a lo largo de este curso es el operador pipe %&gt;% (|&gt;). El pipe toma la expresión a su izquierda y la “canaliza” hacia el primer argumento de la expresión a su derecha.\n\nlibrary(dplyr)\n\n# sin pipe\nmean(1:10)\n#&gt; [1] 5.5\n\n# con pipe\n1:10 %&gt;% mean()\n#&gt; [1] 5.5\n1:10 |&gt; mean()\n#&gt; [1] 5.5\n\nEl pipe hace que el código sea mucho más legible al evitar llamadas de funciones anidadas, reducir la necesidad de variables intermedias y permitir que las operaciones secuenciales se lean de izquierda a derecha. Por ejemplo, para agregar una nueva variable a una base de datos y luego resumir agrupando por otra variable, podemos hacer cualquiera de las siguientes opciones:\n\n## OPCION 1 ##\n# Variables intermedias\nmtcars_kg &lt;- mutate(mtcars, wt_kg = 454 * wt)\nmtcars_grouped &lt;- group_by(mtcars_kg, cyl)\nsummarize(mtcars_grouped, wt_kg = mean(wt_kg))\n#&gt; # A tibble: 3 × 2\n#&gt;     cyl wt_kg\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4 1038.\n#&gt; 2     6 1415.\n#&gt; 3     8 1816.\n\n# Funciones anidadas\nsummarize(\n  group_by(\n    mutate(mtcars, wt_kg = 454 * wt),\n    cyl\n  ),\n  wt_kg = mean(wt_kg)\n)\n#&gt; # A tibble: 3 × 2\n#&gt;     cyl wt_kg\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4 1038.\n#&gt; 2     6 1415.\n#&gt; 3     8 1816.\n## OPCION 2 ##\n# uso de pipes\nmtcars %&gt;% \n  mutate(wt_kg = 454 * wt) %&gt;% \n  group_by(cyl) %&gt;% \n  summarize(wt_kg = mean(wt_kg))\n#&gt; # A tibble: 3 × 2\n#&gt;     cyl wt_kg\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4 1038.\n#&gt; 2     6 1415.\n#&gt; 3     8 1816.\n\nComo se ve en el ejercicio, el uso de pipes reduce el código evitando la creación de variables intermedias.\n\n\n\n\n\n\nEjercicio\n\n\n\nReescribe el siguiente código usando pipes:\n\nset.seed(1)\nround(log(runif(10, min = 0.5)), 1)\n#&gt;  [1] -0.5 -0.4 -0.2  0.0 -0.5 -0.1  0.0 -0.2 -0.2 -0.6\n\n\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nset.seed(1)\nrunif(10, min = 0.5) %&gt;% \n  log() %&gt;% \n  round(digits = 1)\n#&gt;  [1] -0.5 -0.4 -0.2  0.0 -0.5 -0.1  0.0 -0.2 -0.2 -0.6\n\nrunif(10, min = 0.5) |&gt; \n  log() |&gt; \n  round(digits = 1)\n#&gt;  [1] -0.5 -0.5 -0.2 -0.4 -0.1 -0.3 -0.2  0.0 -0.4 -0.1",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción al entorno R en el contexto de eBird</span>"
    ]
  },
  {
    "objectID": "index.html#sec-intro-config",
    "href": "index.html#sec-intro-config",
    "title": "Curso ROC: Análisis de datos de eBird utilizando R",
    "section": "Configuración",
    "text": "Configuración\nEste cruso está pensado para ser interactivo. Todos los ejemplos están escritos en el lenguaje de programación R, y el instructor los irá resolviendo en tiempo real. Recomendamos seguir la clase seguirlo escribiendo el mismo código en su computador. Para evitar retrasos innecesarios, siga estas instrucciones de configuración antes del curso:\n\nCrea una cuenta de eBird si aún no tiene una y solicita acceso a los datos crudos de eBird y a los productos de Estados y Tendencias:\n\nSolicita acceso al eBird Basic Dataset (EBD).\nSolicita acceso a los productos de Estados y Tendencias\n\nDescarga e instala la última versión de R. Se requiere la versión 4.0.0 o posterior de R para poder seguir este curso\nDescarga e instala la última versión de RStudio. RStudio no es necesario para este taller; sin embargo, los instructores lo utilizarán y es posible que te resulte más fácil seguir el curso si trabajas en el mismo entorno.\nLos ejercicios de este curso utilizan varios paquetes de R. Para instalar todos los paquetes necesarios, ejecute el siguiente código\n\n\nif (!requireNamespace(\"remotes\", quietly = TRUE)) {\n  install.packages(\"remotes\")\n}\nremotes::install_github(\"ebird/ebird-best-practices\")\n\n\nAsegúrate de que todos los paquetes estén actualizados a sus versiones más recientes haciendo clic en el botón Actualizar de la pestaña Paquetes en RStudio.\nDescarga el paquete de datos que utilizaremos en este curso.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#sec-tutorial-config",
    "href": "index.html#sec-tutorial-config",
    "title": "Curso ROC: Análisis de datos de eBird utilizando R",
    "section": "Tutorial de configuración",
    "text": "Tutorial de configuración\nHemos creado un video introductorio explicando los pasos a seguir para la descarga e instalación de todos los requerimientos del curso.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "intror.html#software",
    "href": "intror.html#software",
    "title": "1  Introducción al entorno R en el contexto de eBird",
    "section": "1.3 Software",
    "text": "1.3 Software\nLos ejemplos del curso usan el lenguaje R (R Core Team 2023). Si no tienes R instalado, descárgalo. Si ya lo tienes, puede que esté desactualizado: conviene actualizarlo a la versión más reciente. R se actualiza con frecuencia, y es importante contar con la versión más reciente para evitar problemas al instalar paquetes.\nRecomendamos usar RStudio si eres usuario de R. RStudio no es obligatorio para seguir esta guía, pero mejora muchísimo la experiencia. Si no lo tienes, descárgalo; si ya lo tienes, actualízalo, pues regularmente aparecen versiones nuevas con características útiles.\nDebido al tamaño grande del conjunto de datos de eBird, trabajar con él requiere la utilidad de línea de comandos Unix AWK. No necesitas usar AWK directamente, porque el paquete R auk se encarga de hacerlo, pero sí debes tener AWK instalado en tu computador:\n\nEn Linux y macOS ya suele venir AWK instalado.\nEn Windows, necesitarás instalar Cygwin, un software libre que permite usar herramientas Unix bajo Windows. Asegúrate de instalarlo en la ubicación predeterminada (por ejemplo, C:/cygwin/bin/gawk.exe o C:/cygwin64/bin/gawk.exe) para que todo funcione correctamente. Si tienes dudas con esto, puedes volver al video introductorio en el se muestra este paso.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción al entorno R en el contexto de eBird</span>"
    ]
  },
  {
    "objectID": "intror.html#datos-gis-cartográficos",
    "href": "intror.html#datos-gis-cartográficos",
    "title": "1  Introducción al entorno R en el contexto de eBird",
    "section": "1.4 Datos GIS / cartográficos",
    "text": "1.4 Datos GIS / cartográficos\nPara dar contexto espacial a los análisis que realicemos, necesitaremos datos GIS (bordes políticos, límites, etc.). Natural Earth es una de las mejores fuentes de datos GIS vectoriales y raster integrados de calidad profesional. Con el paquete rnaturalearth de R pueden acceder a esos datos fácilmente desde R.\nEl siguiente código descarga datos cartográficos de Natural Earth y crea un archivo GeoPackage con diferentes capas geográficas de Chile.\n\nlibrary(rnaturalearth)\nlibrary(sf) \nlibrary(dplyr)\n\n# Definir la ruta y nombre del archivo GeoPackage donde guardaremos todo\ngpkg_file &lt;- \"data/gis-data-chile.gpkg\"\n\n# Crear el directorio 'data/' si no existe\ndir.create(dirname(gpkg_file), showWarnings = FALSE, recursive = TRUE)\n\n# Descargar y procesar territorio de Chile\n  #Descargar datos de todos los países del mundo\nchile_land &lt;- ne_download(\n  scale = 50, # scale = 50 es una escala intermedia (también existe 10 y 110)\n  category = \"cultural\",\n  type = \"admin_0_countries_lakes\", \n  returnclass = \"sf\"\n) |&gt;\n  # Filtrar solo Chile\n  filter(ADMIN == \"Chile\") |&gt;\n  # Ajustar precisión para evitar problemas geométricos\n  st_set_precision(1e6) |&gt;\n  # Unir todas las geometrías en una sola (incluyendo islas)\n  st_union()\n#&gt; Reading layer `ne_50m_admin_0_countries_lakes' from data source \n#&gt;   `/private/var/folders/hl/htdls_lx1rlfx23h9wwv62xm0000gn/T/RtmpXR5YCT/ne_50m_admin_0_countries_lakes.shp' \n#&gt;   using driver `ESRI Shapefile'\n#&gt; Simple feature collection with 242 features and 168 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -180 ymin: -90 xmax: 180 ymax: 83.6\n#&gt; Geodetic CRS:  WGS 84\n\n# Descargar regiones de Chile (divisiones administrativas)\n  # Descargar divisiones administrativas de nivel 1 (regiones/estados)\nchile_regions &lt;- ne_download(\n  scale = 50,\n  category = \"cultural\", \n  type = \"admin_1_states_provinces\",\n  returnclass = \"sf\"\n) |&gt;\n  filter(iso_a2 == \"CL\") |&gt;\n  # Seleccionar columnas relevantes\n  select(\n    region = name             # Nombre de la región\n  )\n#&gt; Reading layer `ne_50m_admin_1_states_provinces' from data source \n#&gt;   `/private/var/folders/hl/htdls_lx1rlfx23h9wwv62xm0000gn/T/RtmpXR5YCT/ne_50m_admin_1_states_provinces.shp' \n#&gt;   using driver `ESRI Shapefile'\n#&gt; Simple feature collection with 294 features and 121 fields\n#&gt; Geometry type: MULTIPOLYGON\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -180 ymin: -47 xmax: 180 ymax: 83.1\n#&gt; Geodetic CRS:  WGS 84\n\n# Descargar líneas fronterizas de Chile\n  # Primero obtenemos TODAS las líneas fronterizas del mundo\nall_country_lines &lt;- ne_download(\n  scale = 50, \n  category = \"cultural\",\n  type = \"admin_0_boundary_lines_land\",\n  returnclass = \"sf\"\n)\n#&gt; Reading layer `ne_50m_admin_0_boundary_lines_land' from data source \n#&gt;   `/private/var/folders/hl/htdls_lx1rlfx23h9wwv62xm0000gn/T/RtmpXR5YCT/ne_50m_admin_0_boundary_lines_land.shp' \n#&gt;   using driver `ESRI Shapefile'\n#&gt; Simple feature collection with 390 features and 39 fields\n#&gt; Geometry type: MULTILINESTRING\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -141 ymin: -55.1 xmax: 146 ymax: 70.1\n#&gt; Geodetic CRS:  WGS 84\n\n# Identificamos qué líneas intersectan con el territorio de Chile\nlines_touching_chile &lt;- st_intersects(\n  all_country_lines, \n  chile_land, \n  sparse = FALSE\n)[,1]  \n\n# Filtrar solo las líneas que tocan Chile (fronteras con Argentina, Perú, Bolivia)\nchile_country_lines &lt;- all_country_lines[lines_touching_chile,] |&gt;\n  st_geometry() \n\n# Descargar líneas entre regiones\n  # Descargar líneas de divisiones administrativas nivel 1\nall_region_lines &lt;- ne_download(\n  scale = 50,\n  category = \"cultural\",\n  type = \"admin_1_states_provinces_lines\",\n  returnclass = \"sf\"\n)\n#&gt; Reading layer `ne_50m_admin_1_states_provinces_lines' from data source \n#&gt;   `/private/var/folders/hl/htdls_lx1rlfx23h9wwv62xm0000gn/T/RtmpXR5YCT/ne_50m_admin_1_states_provinces_lines.shp' \n#&gt;   using driver `ESRI Shapefile'\n#&gt; Simple feature collection with 581 features and 43 fields\n#&gt; Geometry type: MULTILINESTRING\n#&gt; Dimension:     XY\n#&gt; Bounding box:  xmin: -139 ymin: -38.1 xmax: 174 ymax: 78.7\n#&gt; Geodetic CRS:  WGS 84\n\n  # Filtrar líneas que intersectan con Chile\nlines_in_chile &lt;- st_intersects(\n  all_region_lines,\n  chile_land,\n  sparse = FALSE\n)[,1] \n\nchile_region_lines &lt;- all_region_lines[lines_in_chile,] |&gt;\n  st_geometry()\n\n# Guardar todas las capas en el GeoPackage\nwrite_sf(chile_land, gpkg_file, \"chile_territorio\")\nwrite_sf(chile_regions, gpkg_file, \"chile_regiones\")\nwrite_sf(chile_country_lines, gpkg_file, \"chile_fronteras\")\nwrite_sf(chile_region_lines, gpkg_file, \"chile_limites_regionales\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción al entorno R en el contexto de eBird</span>"
    ]
  },
  {
    "objectID": "intror.html#acceso-a-datos-de-ebird",
    "href": "intror.html#acceso-a-datos-de-ebird",
    "title": "1  Introducción al entorno R en el contexto de eBird",
    "section": "2.1 Acceso a datos de eBird",
    "text": "2.1 Acceso a datos de eBird\nEl acceso a la base de datos de eBird se proporciona a través del eBird Basic Dataset (EBD) como archivos de texto separados por tabulaciones. Para acceder al EBD, comienza creando una cuenta de eBird e iniciando sesión. Luego visita la página de Acceso a Datos de eBird y completa el formulario de solicitud de datos. El acceso a los datos de eBird es gratuito para la mayoría de los usos; sin embargo, necesitarás solicitar acceso para poder descargar el EBD. Completar el formulario de solicitud de acceso permite a eBird hacer seguimiento del número de personas que usan los datos y obtener información sobre las aplicaciones para las cuales se utilizan los datos.\nUna vez que se te haya otorgado acceso al EBD, podrás descargar ya sea el conjunto de datos completo de eBird o subconjuntos para especies, regiones o períodos de tiempo específicos. Esto se lo veremos con más detalle en la última sección.\nLos datos de eBird se organizan en checklist, estos listados representan observaciones de un único evento de observación de aves, como una caminata de 1 km por un parque o 15 minutos observando comederos en tu jardín. Cada listado incluye las especies observadas, el número de individuos vistos de cada especie, la ubicación y hora de las observaciones, información sobre el tipo de muestreo realizado, y medidas del esfuerzo invertido durante la recolección de datos. La siguiente imagen muestra una lista típica de eBird tal como se ve en el sitio web de eBird:\n\n\n\n\n\nHay tres características clave que distinguen a eBird de muchos otros proyectos de ciencia ciudadana y que facilitan análisis ecológicos robustos. Primero, los observadores especifican el protocolo de muestreo utilizado, ya sea en tránsito, estacionario, incidental (es decir, si las observaciones se recolectaron cuando observar aves no era la actividad principal). Segundo, además de la información usual sobre cuándo y dónde se hicieron las observaciones, los observadores registran información de esfuerzo especificando cuánto tiempo buscaron, qué distancia recorrieron y el número total de observadores en su grupo. Recolectar estos datos facilita análisis robustos al permitir a los investigadores controlar la variación en el proceso de observación (La Sorte et al. 2018; Kelling et al. 2018). Finalmente, se pide a los observadores que indiquen si están reportando todas las aves que pudieron detectar e identificar. Las listas con todas las especies reportadas, conocidas como listas completas, permiten a los investigadores inferir conteos de cero individuos para las especies que no fueron reportadas. Si las listas no son completas, no es posible determinar si la ausencia de una especie en la lista fue una no detección o el resultado de que el participante no registró la especie.\nLos proyectos de ciencia ciudadana ocurren en un espectro, desde aquellos con estructuras de muestreo predefinidas que se asemejan más a diseños tradicionales de muestreo (como el Breeding Bird Survey en Estados Unidos), hasta aquellos que no están estructurados y recolectan observaciones de manera oportunista (como iNaturalist). Nos referimos a eBird como un proyecto semi-estructurado (Kelling et al. 2018), con protocolos flexibles y fáciles de seguir que atraen a muchos participantes, pero que también recolectan datos sobre el proceso de observación y permiten inferir no detecciones en listas completas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción al entorno R en el contexto de eBird</span>"
    ]
  },
  {
    "objectID": "intror.html#desafíos-asociados-con-datos-de-ebird",
    "href": "intror.html#desafíos-asociados-con-datos-de-ebird",
    "title": "1  Introducción al entorno R en el contexto de eBird",
    "section": "2.2 Desafíos asociados con datos de eBird",
    "text": "2.2 Desafíos asociados con datos de eBird\nA pesar de las fortalezas de los datos de eBird, las observaciones de especies recolectadas a través de proyectos de ciencia ciudadana presentan una serie de desafíos que no se encuentran en datos científicos convencionales. Los siguientes son algunos de los principales desafíos asociados con estos datos; desafíos que serán abordados a lo largo de esta guía:\n\nSesgo taxonómico: los participantes a menudo tienen preferencias por ciertas especies, lo que puede llevar a un registro preferencial de algunas especies sobre otras (Greenwood 2007; Tulloch and Szabo 2012). Restringir los análisis a listas completas mitiga en gran medida este problema.\nSesgo espacial: la mayoría de los participantes en proyectos de ciencia ciudadana muestrean cerca de sus hogares (Luck et al. 2004), en áreas de fácil acceso como bordes de carreteras (Kadmon, Farber, and Danin 2004), o en áreas y hábitats de alta biodiversidad conocida (Prendergast et al. 1993). Un método simple para reducir el sesgo espacial es crear una grilla sobre la región de interés y muestrear un número determinado de listas desde cada celda de la grilla.\nSesgo temporal: los participantes muestrean preferentemente cuando están disponibles, como los fines de semana (Courter et al. 2013), y en épocas del año cuando esperan observar más aves; notablemente, en Estados Unidos hay un gran aumento en envíos de eBird durante la migración de primavera (Sullivan et al. 2014). Además, eBird ha aumentado constantemente en popularidad con el tiempo, lo que lleva a un fuerte sesgo hacia más datos en años recientes. Para abordar el sesgo de fin de semana, recomendamos usar una escala temporal de una semana o varias semanas para la mayoría de los análisis. Los sesgos temporales a escalas más largas pueden abordarse submuestreando los datos para producir una distribución temporal más uniforme.\nDesbalance de clases: las especies de aves que son raras o difíciles de detectar pueden tener datos con alto desbalance de clases, con muchas más listas con no detecciones que con detecciones. Para estas especies, un modelo de distribución que predice que la especie está ausente en todas partes tendrá alta precisión, pero ningún valor ecológico. Seguiremos los métodos para abordar el desbalance de clases propuestos por Robinson et al. (2018), muestreando los datos para aumentar artificialmente la prevalencia de detecciones antes del modelado.\nPrecisión espacial: la ubicación espacial de una lista de eBird se proporciona como un único punto latitud-longitud; sin embargo, esto puede no ser preciso por dos razones principales. Primero, para listas en tránsito, esta ubicación representa solo un punto en el recorrido. Segundo, las listas de eBird a menudo se asignan a un hotspot (una ubicación común para todos los observadores que visitan un sitio popular) en lugar de su ubicación verdadera. Por estas razones, no es apropiado alinear las ubicaciones de eBird con variables de hábitat muy precisas, y recomendamos resumir variables dentro de un vecindario alrededor de la ubicación de la lista.\nVariación en detectabilidad/esfuerzo: la detectabilidad describe la probabilidad de que una especie este presente en un área y sea detectada e identificada. La detectabilidad varía según la estación, hábitat y especie (Johnston et al. 2014, 2018). Además, los datos de eBird se recolectan con alta variación en esfuerzo, hora del día, número de observadores y condiciones externas como el clima, todo lo cual puede afectar la detectabilidad de las especies (Ellis and Taylor 2018; Oliveira et al. 2018). Por lo tanto, la detectabilidad es particularmente importante de considerar al comparar entre estaciones, hábitats o especies. Dado que eBird usa un protocolo semi-estructurado que recolecta datos sobre el proceso de observación, podremos controlar una mayor proporción de esta variación en nuestros análisis.\n\nEl resto de esta guía demostrará cómo abordar estos desafíos usando datos reales de eBird para producir estimaciones confiables de distribuciones de especies. En general, tomaremos un enfoque de dos frentes para lidiar con datos no estructurados y maximizar el valor de los datos de ciencia ciudadana: imponer más estructura en los datos mediante filtrado e incluir variables predictoras que describan el proceso de observación en nuestros modelos para controlar la variación restante.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción al entorno R en el contexto de eBird</span>"
    ]
  },
  {
    "objectID": "intror.html#descarga-de-datos",
    "href": "intror.html#descarga-de-datos",
    "title": "1  Introducción al entorno R en el contexto de eBird",
    "section": "2.2 Descarga de datos",
    "text": "2.2 Descarga de datos\nLos datos de eBird se distribuyen típicamente en dos partes: datos de observación y datos de lista. En el conjunto de datos de observación, cada fila corresponde al avistamiento de una única especie en una lista, incluyendo el conteo y cualquier otra información a nivel de especie (por ejemplo, edad, sexo, comentarios sobre la especie, etc.). En el conjunto de datos de lista, cada fila corresponde a una lista, incluyendo la fecha, hora, ubicación, esfuerzo (por ejemplo, distancia recorrida, tiempo invertido, etc.) y cualquier información adicional a nivel de lista (por ejemplo, si es una lista completa o no). Estos dos conjuntos de datos pueden unirse usando un identificador único de lista (a veces referido como identificador de evento de muestreo).\nLos datos de observación y lista se publican como archivos de texto separados por tabulaciones, referidos como el eBird Basic Dataset (EBD) y el Sampling Event Data (SED), respectivamente. Estos archivos se publican mensualmente y contienen todos los avistamientos de aves validados en la base de datos de eBird al momento de la publicación. Ambos conjuntos de datos pueden descargarse en su totalidad, o de manera más práctica, se puede solicitar un subconjunto para una especie, región o período de tiempo determinados a través del formulario de Descarga Personalizada (Custom Download). Recomendamos enfáticamente no intentar descargar el EBD completo, ya que supera los 100GB. En esta sección demostraremos un flujo de trabajo usando el enfoque de Descarga Personalizada.\nComenzaremos descargando los datos de observación (EBD) y de lista (SED) de eBird correspondientes visitando la página de descarga del eBird Basic Dataset y completando el formulario de Descarga Personalizada. Asegúrate de marcar la casilla “Include sampling event data”, que incluirá el SED en la descarga de datos además del EBD.\n\n\n\n\n\nUna vez que los datos estén listos, recibirás un correo electrónico con un enlace de descarga. Los datos descargados estarán en formato comprimido .zip y deberán descomprimirse. El directorio resultante contendrá dos archivos de texto: uno para el EBD (por ejemplo, ebd_CL-LL_smp_relAug-2025.txt) que contiene todas las observaciones del país y uno para el SED (por ejemplo, ebd_CL-LL_smp_relAug-2025_sampling.txt) que contiene todas las listas de la región de Los Lagos. El componente relAug-2025 del nombre de los archivos describe qué versión del EBD es este conjunto de datos; en este caso, es la versión de agosto de este año.\nDado que el EBD se actualiza mensualmente, probablemente recibirás una versión diferente de los datos que la versión de agosto de 2025 usada a lo largo del resto de esta lección. Siempre que actualices los nombres de los archivos descargados en consecuencia en tus códigos, la diferencia en versiones no será un problema. Sin embargo, si quieres descargar y usar exactamente los mismos archivos usados en esta lección, puedes descargar el archivo zip del EBD correspondiente.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción al entorno R en el contexto de eBird</span>"
    ]
  }
]